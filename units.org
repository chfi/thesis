# * Units


** Biodalliance/The problem

It is often the case that values in programs are represented using
primitive types, rather than using the fact that different units
in fact can be viewed as different types. When all values are regular
JS numbers, there is nothing to stop the programmer from accidentally
adding a length to a weight, which is likely to lead to problems.
It also becomes more difficult to comprehend what a piece of code does.
# TODO argue for/justify last sentence?

While they are displayed in visualizations, graphs, etc.,
the underlying representation is rarely anything other than a string
or a number. That is, to the computer, there is no semantic difference
between e.g. the position of a basepair on some chromosome, the
volume of a house, or pi -- all of these numbers could be used interchangeably.

# WIP this is the case in Biodalliance
BD uses mainly raw JS numbers and strings for representing its state and data,
with a few JS objects used mainly for more complex information.

# TODO examples

# WIP "solutions" in JS -- tagged objects
One way to solve this problem in JS would be to use something like the
`daggy` library,
# TODO footnote: https://github.com/fantasyland/daggy]
which adds tagged sum "types" to JS. The developer still needs to
make sure they are used correctly, but at least the program will fail
with an error if a value representing a pixel length is supplied to a
function expecting a length in basepairs.

Since Purescript actually has a type checker and built-in sum types, we
expect it to be easier to represent these kinds of units. In fact, Purescript
lets us create new types wrapping existing types, without any runtime cost.
This is done using newtypes.


** Newtypes

Newtypes are one of the ways of creating types in Purescript. They
can only have one single data constructor, and that constructor must
have one single parameter, hence the intuition that they wrap an
existing type. At runtime, values in a newtype are identical to
values of the underlying type, which can be exploited when working with the FFI,
plus there is no performance hit when using newtypes.

** Positions
   Biodalliance uses basepairs (Bp) for all position data, and stores this
data as a regular Javascript Number value. It's not uncommon for data
to provide its position information in megabasepairs (MBp). Obviously,
treating a Bp as an MBp, or vice versa, leads to problems, but if it's
just a Number being thrown around, there's no way to avoid the problem
other than trusting the programmer and user to do things correctly.

As a programmer and user, I find the idea of doing so reprehensible,
hence the Bp and MBp newtypes:

# TODO add link to lines in Units.purs
#+name: code:units-pos-1
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
newtype Bp = Bp Number
newtype MBp = MBp Number
#+END_SRC

To work with these, we can use pattern matching:

#+name: code:units-pos-2
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
toBp :: Number -> Bp
toBp x = Bp x

fromBp :: Bp -> Number
fromBp (Bp x) = x
#+END_SRC

However, Purescript provides a typeclass to minimize this boilerplate,
namely the `Newtype` typeclass. The compiler derives the instance, and
we can then use the generic `wrap` and `unwrap` functions:

#+name: code:units-pos-3
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
derive instance newtypeBp :: Newtype Bp _
derive instance newtypeMBp :: Newtype MBp _

mbpToBp :: MBp -> Bp
mbpToBp x = wrap $ (unwrap x) * 1000000.0
#+END_SRC

Purescript also provides facilities for deriving typeclass instances for newtypes.
Deriving the typeclasses used in arithmetic lets us use normal operators when
working with Bp and MBp:

# TODO: maybe note that most of this doesn't make very much sense, e.g. multiplying
# two Bp's is in fact pretty silly. Would probably be "better" to use a semigroup
# where <> is addition...


# TODO this one needs to be reformatted
# TODO all of these `derive newtype instance` are unnecessary in both code and report...
#+name: code:units-pos-4
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
derive newtype instance eqBp :: Eq Bp
derive newtype instance ordBp :: Ord Bp
derive newtype instance fieldBp :: Field Bp
derive newtype instance euclideanRingBp :: EuclideanRing Bp
derive newtype instance commutativeRingBp :: CommutativeRing Bp
derive newtype instance semiringBp :: Semiring Bp
derive newtype instance ringBp :: Ring Bp

-- now we can do
p1 = Bp 123.0
p2 = Bp 400.0

-- p1 + p2 == Bp 523.0
#+END_SRC



** Chromosomes
Biodalliance represents chromosome identifiers as strings. Like with Bp,
a newtype wrapper helps keep track of things:

#+name: code:units-chrs-1
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
newtype Chr = Chr String
derive instance newtypeChr :: Newtype Chr _
derive newtype instance eqChr :: Eq Chr
derive newtype instance ordChr :: Ord Chr
derive newtype instance showChr :: Show Chr
#+END_SRC


** Scale
# NOTE: This is currently only used in the Native track, however the old
# BD rendering stuff could/should be refactored to use the new
# BpPerPixel

When drawing data to the screen, we need to be able to transform between
screen coordinates and the coordinates used by data. For simplicity's
sake, we only care about mapping between basepairs and pixels. We represent
this with another newtype wrapping Number:

#+name: code:units-scale-1
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
newtype BpPerPixel = BpPerPixel Number
derive instance newtypeBpPerPixel
  :: Newtype BpPerPixel _

bpToPixels :: BpPerPixel -> Bp -> Number
bpToPixels (BpPerPixel s) (Bp p) = p / s

pixelsToBp :: BpPerPixel -> Number -> Bp
pixelsToBp (BpPerPixel s) p = Bp $ p * s
#+END_SRC


** Features
In BD, a `feature` is basically any data point. While the feature objects in
BD can become arbitrarily complex as various data parsers construct them
in different ways, there are only three minimal pieces of information required:
what chromosome the feature is on, and what range of basepairs on the chromosome
it covers.

In Purescript, we represent this type as an algebraic data type (ADT).
#+name: code:units-feature-1
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
data Feature c r = Feature Chr c c r
#+END_SRC

For convenience, we let the compiler derive how to compare two `Features`
for equality and order:
# TODO this one needs to be reformatted
#+name: code:units-feature-2
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
derive instance eqFeature :: (Eq c, Eq r) => Eq (Feature c r)
derive instance ordFeature :: (Ord c, Ord r) => Ord (Feature c r)
#+END_SRC

There is also a smart constructor for creating `Features` only with
coordinates that can be transformed to basepairs.

#+name: code:units-feature-3
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
feature :: forall c r.
           HCoordinate c
        => Chr -> c -> c -> r
        -> Feature c r
feature = Feature
#+END_SRC

# TODO show using this bifunctor instance; it's quite nice and handy
Since `Feature` has two type parameters, one for the coordinates and one for the
data, and is covariant in both, we have a bifunctor instance:

#+name: code:units-feature-4
#+caption:
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Units.purs :file Units.purs
instance bifunctorFeature
  :: Bifunctor Feature where
    bimap f g (Feature chr xl xr r) =
      Feature chr (f xl) (f xr) (g r)
#+END_SRC
