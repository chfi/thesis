http://www-public.tem-tsp.eu/~gibson/Teaching/Teaching-ReadingMaterial/BeckFowler99.pdf

*** Our smells

**** Which of the above don't apply to FP (or are less important)

- Long Method
  Immutable state makes this less difficult to follow;
  explicit state makes this less likely to happen.

- Long Parameter List
  Could in fact be a bonus thanks to currying!

- Divergent Change
  Applies to new data types. However, ADTs and HKTs give us more tools to fix this
  and refactor to not do this -- not to mention static types in general!

- Switch Statements
  Argues that OOP provides polymorphism to take care of this;
  typed FP and pattern matching is not the same as imperative switches

  BD does misuse switches; or rather loooong if-else-if's, since JS doesn't
have switch statements. Terrible; esp. drawing glyphs/"parsing" styles etc.

the whole prepareSubtiers etc. bit could be a chapter on its own

  Pattern matching instead.

- Parallel Inheritance Hierarchies
  "in this case, every time you make a subclass of one class, you also have
   to make a subclass of another."

Kind of a problem with glyphs; or its dual. Each "interface" the glyph support
is duplicated over all the glyphs, changing the SVG export would require
changing some 20-30 classes.

Also probably an issue with the different tiers and stuff.

  Not a thing.

- Lazy Class
  A class that's been reduced in size and importance due to refactoring;
  would be better off without it

- Speculative Generality
  Abstracting too early -- certainly a potential problem in FP, though
  you're more likely to crash and burn and waste time, rather than
  introduce problems (won't compile anyway)

Does BD do this? You can see some signs of it in the various DAS* classes,
which are now generalized to all tiers. wait -- that's the opposite...

  Both of these: more likely to cause an unnecessary growth rather than something that interferes
  with the rest. Also easy to fix

- Temporary Field
  When an object's field is only set in certain circumstances;
  makes it more difficult to reason about the class.
  (One-up that with immutability and purity)

  Not applicable in a language without `null`, also not applicable in a pure/immutable environment.

- Message Chains
  "You may see this as a long line of getThis methods, or as a sequence of temps."
  E.g. all of BD (sending drawing callback 10 functions deep etc.)

  In OOP this is seen as something bad;
  in FP this and `Middle Man` are the key building blocks of abstraction!

- Middle Man
  When encapsulation goes to the point of one class mainly delegating to some other class.

  We have a commonly used function for exactly this purpose, namely,
  compose :: (a -> b) -> (b -> c) -> a -> c


- Inappropriate Intimacy
  When classes know too much about other instances of other classes (esp. fields/methods
that should be private).
  Solution is to extract common code to a new class.
  Strictly typed FP doesn't have this problem at all.

  You can only look as far into a type as the in-scope tools give you.
  Purescript's idiom of explicit imports makes it easy to see where such
  tools come from even if they're from another module, so this doesn't apply either.


- Alternative Classes with Different Interfaces
  "Use /Rename Method/ on any methods that do the same thing but
   have different signatures for what they do."
  Parametric polymorphism and typeclasses deal with this;
  powerful types makes refactoring this problem away nearly trivial (depending
  on the complexity of the functions)

  barely applicable in the first place


- Incomplete Library Class

  Basically when a library doesn't implement what we want.
  Less of a problem with the abstractions from category theory;
  their scope is obvious and parametrically polymorphic.
  We can tell *exactly* what such a library provides, and what it cannot provide.
  Otherwise typeclasses and newtypes help, plus equational reasoning
  and composability of functions.
  Last of all, the book states "The trouble is that it is often bad form,
  and usually impossible, to modify a library class to do something you'd
  like it to do."
  Except it's not, just make a PR!

  Typeclasses and newtypes help with this a lot, also

- Data Class
  Classes that have only fields and getters and setters.
  Complains that the main purpose of these classes are to be manipulated by
  other classes; I disagree that that is a problem...
  Obviously superceded by 1st class record types. (Plus immutability and purity...)

  Immutability makes this irrelevant.

- Refused Bequest

  When a subclass doesn't make use of all of its inherited method and data.
  Doesn't apply to FP, obviously.

  Not applicable. A typeclass that has another as a superclass
  has access to all of the superclass' methods. Even if the
  subclass' methods don't use all of the superclass, types that are constrained
  to the subclass still have the superclass' methods -- and so do functions
  similarly constrained.

- Shotgun Surgery
  Not applicable to any great extent. Changing types may cause this; however
  you're likely to get compiler errors telling you exactly what is left to change.


- Feature Envy
  When a class/object gets a bunch of data/methods from another class/object?
  Book suggests Strategy and Visitor patterns from Gang of Four...

  the strategy pattern: defines a family of encapsulated and interchangeable algorithms.
  e.g. sorting in different ways.
    in FP, this is just a higher order function.

  the visitor pattern: solves the problem of defining new operations on some classes
  of an object structure without changing the classes.

  defines a visitor object that implements an operation to be performed on the elements.
    in FP this is just... Functor? Maybe Traversable? Either way, it's not much of a thing.



**** Others

- Duplicated Code
  I think there's a fair bit of this in BD...

Examples:
  + glyphs!!
  +

- Large Class
  Large type!

- Primitive Obsession
  this is a good one for both OOP and FP! But especially langs like PS.
  "Most programming environments have two kinds of data. Record types
allow you to structure data into meaningful groups. Primitive types are your
building blocks. Records always carry a certain amount of overhead. They may
mean tables in a database, or they may be awkward to create when you want them
for only one or two things."

Except PS has newtypes and 1st class records, and it's easy to create new ADTs.
Big problem in BD, as much of the internal data is basically stringly typed.
foreign data imports are also helpful

could be argued that this is one of the cooler things you get with a type system
like Purescript's.

- Data Clumps
  When you notice several variables/fields that are often used together
  in parameters, methods, etc.
  Argues that these should be combined into a value, which makes some sense.
  Would probably just use records in PS, or maybe typeclasses.
  Either way the problem is mitigated simply by FP

  yeah BD does this

- Comments
  Not using comments as a "deodorant"
  FP is as guilty of this; though static types come in as docs


**** What are the problems, exactly?

Difficult to understand code.

But what makes it difficult? And what is it we want to understand?
What do we even mean by "code"?
Is there a difference between understanding the code and understanding the program?
(yes; less so in FP).

To understand what a piece of code does is to understand how it transforms its
input to some output, and what effects it performs while doing so. That is,
when one has a mental model of what will change when a piece of code is run;
one that is congruent to what it actually does. These effects, these transformations,
can be anything.

Understanding the program as a whole consists of understanding how it is used,
what its inputs are, and what and how it can output data, including UI interactions.

If we want to extend a program, we need to delve into the code.
If the code that the program consists of does not fit the semantics of the program,
we're in trouble.

We're also in trouble if we want to extend a program P that has semantics S1,
with semantics S2, but our implementation C1 of semantics S1 is incompatible
with all (or most, or the good) implementations C' of S2. If S1 and S2 are
compatible, then so should C1 and C2 be. (this is meta and soft as *fuck*)


In short -- code smells are anything and everything that reduce the
possible future implementation space without good reason.


What we want is to increase the possible implementation space without changing
the existing implementation. By transitivity, we're not doing anything in PS
that cannot be done in BD. What we *are* doing, is doing this in a way such
that the new implementation is closer to the intended program semantics
-- for some definition of "closer".




"Why functional programming matters"
"How functional programming mattered"

"A Taxonomy and an Initial Empirical Study of Bad Smells in Code"
http://ai2-s2-pdfs.s3.amazonaws.com/c8eb/4de02f0614969f9e1681b8125deeb0060fd4.pdf


Some examples of code smells/architecture problems

Other potential issues:
- Mutable state
- Doing all kinds of stuff all over -- impossible to refactor reasonably;
  lack of not only equational reasoning/purity, but even any approximation of it

** Purpose
Identifying code smells in a legacy code base;
identifying their problems -- why do they inhibit maintainability/extensibility;
how can PS be used to reduce the problem, or keep it from appearing in the first place
