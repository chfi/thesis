* User interface
The main function of GGB's user interface is to tie the browser tracks --
BD and Cy.js -- together. It also creates and to some extent manages
the JS browser track instances, and renders the HTML for the entire
UI.


** Biodalliance
# WIP BD intro
Biodalliance has a full-featured UI for exploring genomic data chromosome-wise,
adding and removing currently displayed tracks, configuring browser options, and
exporting the current browser view to various formats. BD accomplishes this by
creating and working with DOM elements and the HTML5 canvas API, and setting
handlers on DOM events such as clicking and dragging the browser view, or
pressing the arrow keys to scroll.

# WIP DOM actions
Because BD does not use any abstracting library for dealing with the DOM, and
likely because BD has grown features organically over time, the code for
updating the UI is interleaved with other code, including event handlers,
fetching data for a track, and more. BD also programmatically sets various CSS
properties on UI elements, and uses the web browser's computed stylesheet to
figure what manipulations are necessary.

# TODO example

# TODO Events
  # NOTE: mainly covered in events.org

# TODO example

# WIP Problems
In short, BD's UI uses plenty of global state, and is highly complex and
spread out over the codebase. Adding a UI element would require finding
a place in the DOM where it would fit -- both in screen estate as well
as in styling --  and somehow suture it into the code while making sure
that the existing UI elements are not negatively affected by this sudden
new element, plus that the other UI elements and functionality do not
interact with the element in some undesired manner.

Another problem, that could arise when adding some feature, not necessarily
modifying the UI itself, is the risk of the interface ending up in an
inconsistent state. With all the global state that is used, both in the
DOM and in the BD browser itself, it is difficult to know what changes
can be made. One cannot even call a function which performs some action
when a button is clicked, without risking that the function itself
toggles some state.

# WIP How we do it in PS
In Purescript, we do not juggle DOM elements and events. Instead, we use
Halogen, from purescript-halogen, a type-safe UI library, similar in purpose to
React. Event passing between tracks is taken care of by purescript-aff-bus and
threads from purescript-aff, while DOM events are handled by Halogen.

Using these tools, we can construct a potentially complex UI, with some,
albeit not absolute, confidence that the UI will not move to an inconsistent
state. Halogen also provides a DSL for declaratively constructing the
DOM of our application. Naturally, there is no implicit global state to
be concerned about.


** Quick Halogen intro
Halogen is a component-based UI library, using a virtual DOM implementation
to render HTML to the browser. A component is a value of the (fairly complicated)
type Component (removed constraints etc. for clarity):

#+name: code:ui-halogen-1
#+BEGIN_SRC purescript
component ::
  Component   -- (1)
    renderer  -- (2)
    query     -- (3)
    state     -- (4)
    message   -- (5)
    monad     -- (6)
#+END_SRC

The type `Component (1)` takes five type parameters. The first,
`renderer (2)` is the type used to render the page, we use a HTML
renderer. Next is `query (3)`, which is filled with our query algebra,
to be explained later; in short it is the set of commands the component
can respond to. `state (4)` is the type of the state kept by
the component. We don't have any, so we set it to `Unit`. `message (5)`
is the type of messages we can produce, which we can send to other
parts of the program.  Finally, `monad (6)` is the type in which all
effects produced by the component will happen. In our case, it's the
`Aff` monad for asynchronous effects -- it could also be a monad transformer
stack, or some free monad.

*** Query algebras

The "Query algebra" is the type describing the possible actions we can query
the component to perform. The type is not complicated; in GGB we have:

#+name: code:ui-algebras-1
#+BEGIN_SRC purescript
data Query a
  = CreateBD (forall eff.
              HTMLElement
           -> Eff (bd :: BD | eff)
              Biodalliance) a
  | PropagateMessage Message a
  | BDScroll Bp a
  | BDJump Chr Bp Bp a
  | CreateCy String a
  | ResetCy a
#+END_SRC

From top to bottom, we can ask it to `CreateBD`, providing a function that
creates a Biodalliance instance given a HTML element to place it in;
we can propagate messages from the child components; we can scroll and
jump the BD instance; and we can create and reset the Cy.js instance.
That's what the queries look like, but we also need to define an `eval`
function. This maps Query to Halogen commands, which are also defined
by a functor type -- the function is a natural transformation from
our Query DSL to the Halogen DSL (a free monad).

# TODO this one needs to be reformatted
#+name: code:ui-algebras-2
#+BEGIN_SRC purescript
eval :: Query
     ~> HalogenM
          state
          query
          childQuery
          childSlot
          message
          monad
#+END_SRC

The type parameters of `HalogenM` are the same as those of
`Component`, adding a `childQuery` type, the Query type of values
which this component can use to communicate with its children, and
`childSlot`, the type which is used to index into the child
components. For the main GGB component they are:

#+name: code:ui-algebras-3
#+BEGIN_SRC purescript
type ChildSlot = Either2 UIBD.Slot UICy.Slot

type ChildQuery = Coproduct2 UIBD.Query UICy.Query
#+END_SRC

`ChildSlot` is a coproduct of the two child Slot /types/ (Either2) of the
child components; we can query the BD slot or the Cy.js slot at once,
not both. `Either2` is a generalization of `Either` to a variable
number of types, a convenience that makes it easy to change the
number of slots, without more work than a type synonym. `ChildQuery`
is a coproduct of the two child Query /functors/ (Coproduct2).

# TODO This product/coproduct stuff is probably overkill
#+name: code:ui-algebras-4
#+BEGIN_SRC purescript
data Either a b =
  Left a | Right b

data Coproduct f g a =
  Coproduct (Either (f a) (g a))
-- can be viewed as (pseudocode):
data Coproduct f g a =
  Coproduct (Left (f a)) | (Right (g a))

type ChildQuery a =
  Either (UIBD.Query a) (UICy.Query a)
#+END_SRC

# TODO: not sure, but it may even be impossible to do this; may not compile
# (certainly doesn't compile when applied to Halogen)

We can't use normal `Either` for ChildQuery, as we wouldn't be able to be
parametric over the `a` type in both child queries. If we were to map a function
`UICy.Query (a -> b)` on the Right component of the Either ChildQuery, we'd end
up with the type `Either (UIBD.Query a) (UICy.Query b)`, which obviously is not
congruent to `ChildQuery a`.

Writing the function is simple enough. We pattern match on the input
Query, and produce effects in the HalogenM type. Creating BD is done
by querying the BD child using its respective slot and a ChildPath --
a type describing a path to the child component, and providing an
action to tell the child component to perform.


#+name: code:ui-algebras-5
#+BEGIN_SRC purescript
eval = case _ of
  CreateBD bd next -> do
    _ <- H.query'
           CP.cp1
           UIBD.Slot
           $ H.action (UIBD.Initialize bd)
    pure next
#+END_SRC

`H.action` is a Halogen
function mapping ChildQuery constructors to concrete actions, by simply
applying the `Unit` type to it.

#+name: code:ui-algebras-6
#+BEGIN_SRC purescript
type Action f = Unit -> f Unit
action :: forall f. Action f -> f Unit
action f = f unit
#+END_SRC

Finally, we return the next command. Next is `PropagateMessage`, which
receives a Message (sent from the function handling messages from the children):

#+name: code:ui-algebras-7
#+BEGIN_SRC purescript
data Message
  = BDInstance Biodalliance
  | CyInstance Cytoscape
#+END_SRC

Depending on which message it is, we print a log message, and then use `H.raise`
to send the message out from Halogen to subscribers elsewhere in the app (more
on that later).

# TODO this one needs to be reformatted?
#+name: code:ui-algebras-8
#+BEGIN_SRC purescript
  PropagateMessage msg next -> do
    case msg of
      BDInstance _ -> liftEff $ log "propagating BD"
      CyInstance _ -> liftEff $ log "propagating Cy"
    H.raise msg
    pure next
#+END_SRC

The rest are simple queries to the respective child component, practically
the same as `CreateBD`:

# TODO this one is probably *also* overkill. more detail than necessary; doesn't actually give much
# TODO this one needs to be reformatted
#+name: code:ui-algebras-9
#+BEGIN_SRC purescript
  BDScroll dist next -> do
    _ <- H.query' CP.cp1 UIBD.Slot $ H.action (UIBD.Scroll dist)
    pure next
  BDJump chr xl xr next -> do
    _ <- H.query' CP.cp1 UIBD.Slot $ H.action (UIBD.Jump chr xl xr)
    pure next

  CreateCy div next -> do
    _ <- H.query' CP.cp2 UICy.Slot $ H.action (UICy.Initialize div)
    pure next
  ResetCy next -> do
    _ <- H.query' CP.cp2 UICy.Slot $ H.action UICy.Reset
    pure next
#+END_SRC

*** Rendering
Next is rendering the component. This is done by providing a function from
the component `state` to a description of the DSL used by the `renderer`
type. In our case, we render to `HTML`, and so use the type `ParentHTML`,
which contains all the types required to interact with the children.

#+name: code:ui-algebras-10
#+BEGIN_SRC purescript
render :: State
       -> ParentHTML
            query
            childQuery
            childSlot
            m
#+END_SRC

The function itself is simple, we use Arrays and some functions to describe
the HTML tree, a simplified version follows:

#+name: code:ui-algebras-11
#+BEGIN_SRC purescript
render _ =
  HH.div_
    [ HH.button
      [  HE.onClick
           $ HE.input_
             $ BDScroll
               $ Bp (-1000000.0) ]
      [ HH.text "Scroll left 1MBp" ]

    , HH.div
      [] [HH.slot'
            CP.cp1
            UIBD.Slot
            UIBD.component
            unit
            handleBDMessage]
    ]
#+END_SRC

This produces a button with the text "Scroll left 1MBp", and clicking on it
sends a query to `eval` to scroll the BD view 1 MBp to the left; as well as a
div with the BD child component. Adding the child component here is how we
create the component, so we must also provide a handler in the parent for
messages from the child, namely `handleBDMessage`.

*** Messages
A component can send messages to its parent, or the rest of the application
in the case of the top-level component. These are the messages the BD and Cy.js
components can produce, respectively:

#+name: code:ui-messages-1
#+BEGIN_SRC purescript
data UIBD.Message
  = SendBD Biodalliance

data UICy.Output
  = SendCy Cytoscape
#+END_SRC

The main component can produce these:
#+name: code:ui-messages-2
#+BEGIN_SRC purescript
data Message
  = BDInstance Biodalliance
  | CyInstance Cytoscape
#+END_SRC

Note that the main container uses its own messages to propagate the children
components; message passing is limited by Halogen, and anything more complex
than this should be done on another channel (which is what GGB does with events).

The messages from the BD and Cy.js components are handled by the functions
`handleBDMessage` and `handleCyMessage`:

#+name: code:ui-messages-3
#+BEGIN_SRC purescript
handleBDMessage :: UIBD.Message
                -> Maybe (Query Unit)
handleBDMessage (UIBD.SendBD bd) =
  Just $ H.action $ PropagateMessage (BDInstance bd)

handleCyMessage :: UICy.Output
                -> Maybe (Query Unit)
handleCyMessage (UICy.SendCy cy) =
  Just $ H.action $ PropagateMessage (CyInstance cy)
#+END_SRC

Note that these produce Queries on the main component. We want to send the
messages containing the references to the instances out from the component to
the outside application, hence creating a PropagateMessage query wrapping the
reference. As seen in `eval` above, this in turn callse `H.raise` on the
message, sending it to the outside world.

*** Creating the component
These functions, including one to produce the initial state (simply `const unit`)
are all put together and provided to the `parentComponent` function,
producing the Component itself. This can then be provided to Halogen's `runUI`
function, along with the initial state and an HTML element to be placed in,
to create and run the Halogen component.

First, however, we need a `main` function application to run.

** The main application

`main` is the function which will be called by the user to run the browser.
It takes a `Foreign` object -- the one to parse into a browser configuration --
and then does some stuff with Eff (e.g. be a genetics browser):

# TODO: remove row blank when compiling with 0.12
# TODO: explain runHalogenAff
#+name: code:ui-main-1
#+BEGIN_SRC purescript
main :: Foreign -> Eff _ Unit
main fConfig = HA.runHalogenAff do
#+END_SRC

First we attempt to parse the provided configuration, logging all errors to
config on failure, otherwise continuing:

#+name: code:ui-main-2
#+BEGIN_SRC purescript
case runExcept $ parseBrowserConfig fConfig of
  Left e -> liftEff $ do
    log "Invalid browser configuration:"
    sequence_ $ log <<< renderForeignError <$> e

  Right (BrowserConfig config) -> do
#+END_SRC

With a validated config, we can create the track/graph configs, and create
the function which will later be used to create Biodalliance:

# TODO this one needs to be reformatted
#+name: code:ui-main-3
#+BEGIN_SRC purescript
let {bdTracks, cyGraphs} = validateConfigs config.tracks

    opts' = sources := bdTracks.results <>
            renderers := config.bdRenderers

liftEff $ log $ "BDTrack errors: " <> foldMap ((<>) ", ") bdTracks.errors
liftEff $ log $ "CyGraph errors: " <> foldMap ((<>) ", ") cyGraphs.errors

let mkBd :: (forall eff. HTMLElement -> Eff (bd :: BD | eff) Biodalliance)
    mkBd = initBD opts' config.wrapRenderer config.browser
#+END_SRC

After picking the element to run in, we create the Halogen component, and
create the Buses to be used by the events system. Note that we bind the
value of `runUI` to `io`:

#+name: code:ui-main-4
#+BEGIN_SRC purescript
io <- runUI component unit el'

busFromBD <- Bus.make
busFromCy <- Bus.make
#+END_SRC


`io` can be used to subscribe to messages sent from the main component,
as well as send queries to it, which we do momentarily. First, we use
the provided TrackSink and TrackSource configurations to create the
BD TrackSink and TrackSource:

# TODO this one needs to be reformatted
#+name: code:ui-main-5
#+BEGIN_SRC purescript
let bdTrackSink =   makeTrackSinks <<< _.bdEventSinks =<<
                      note "No BD event sinks configured" (config.events)
    bdTrackSource = makeTrackSources <<< _.bdEventSources =<<
                      note "No BD event sources configured" (config.events)
#+END_SRC

We create the respective values, adding an error message if something
went wrong.

Finally, we attach a callback to the Halogen component
to listen for the reference to the BD instance, sent by the BD component
upon creation. We then use the TrackSink and TrackSource configurations
to hook BD up to the event system. Finally, we ask the main component
to create the BD instance:

# TODO this one needs to be reformatted
#+name: code:ui-main-6
#+BEGIN_SRC purescript
io.subscribe $ CR.consumer $ case _ of
  BDInstance bd -> do

    case bdTrackSink of
      Left err -> liftEff $ log "No BD TrackSink!"
      Right ts -> forkTrackSink ts bd busFromCy *> pure unit

    liftEff $ case bdTrackSource of
      Left err -> log err
      Right ts -> subscribeBDEvents ts bd busFromBD

      --TODO remove BDRef? debug stuff...
    liftEff $ setBDRef bd
    pure Nothing

  _ -> pure $ Just unit

io.query $ H.action (CreateBD mkBd)
#+END_SRC

If the `TrackSink` was correctly configured, `forkTrackSink` is used
to pipe events from the Cytoscape.js instance to the handler defined
by said `TrackSink`. We don't care about being able to kill the
"thread" using the `Canceler`, so we throw away the result with `*>
pure unit`. Similarly, the `TrackSource` is used with the helper
function `subscribeBDEvents`, defined thusly:

# TODO this one needs to be reformatted
#+name: code:ui-main-7
#+BEGIN_SRC purescript
subscribeBDEvents :: forall r.
                     (TrackSource Event)
                  -> Biodalliance
                  -> BusRW Event
                  -> Eff _ Unit
subscribeBDEvents h bd bus =
  Biodalliance.addFeatureListener bd $ \obj -> do
    let evs = runTrackSource h (unwrap obj)
    traverse_ (\x -> Aff.launchAff $ Bus.write x bus) evs
#+END_SRC

It adds an event listener to the provided BD browser instance and writes
the successful parses to the provided Bus.

The Cytoscape.js code is analogous.
