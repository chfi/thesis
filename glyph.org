# * Glyphs

# Say that rendering data to the screen is obviously important for a viz. tool

# then, since users must be able to interact with the data, it must be
# possible to know where they end up on the screen, so we can map from
# clicked screen coordinates to feature.

# tie these concepts up by presenting them as parallel transformations
# on a single data type that features are transformed to: the Glyph

# maybe have a chart showing it,
# pointing out that the transformations *from* Glyph are data-agnostic;
# they are free if we can provide a way to transform the data to a Glyph

#+begin_comment

  Data-specific
    transformation               -> SVG
                 \              /
            Data -> Glyph - - - -> HTML5 Canvas
                            /   \
                Data-agnostic    -> Bounding Box
                   transformation

#+end_comment


A "glyph" is something that can be drawn to the browser display,
as well as be exported to SVG. They are also what the user interacts
with, and so have bounding boxes that are used to detect whether
the user has clicked on them, to produce browser events.

** Biodalliance

# WIP Biodalliance has a bunch of classes
Biodalliance has a number of Glyphs, which are classes sharing
a basic interface -- they have a function which draws itself
to the canvas, one which produces an SVG element, as well
as functions providing the bounding boxes.

# WIP "higher order" glyphs
The Glyphs range from basic geometric shapes such as boxes and
triangles, to more complex "higher order" ones, which take
other glyphs and e.g. translates them.

# WIP constructor
Glyphs are created using the appropriate constructor, which takes data such
as position on screen, color, and so on. For example, the Glyph to create
a box (rectangle) requires position, size, color, transparency, and
radius (for rounding corners):

# TODO this one needs to be reformatted Done?
#+name: code:glyph-bd-1
#+BEGIN_SRC javascript
function BoxGlyph(x, y,
                  width, height,
                  fill, stroke,
                  alpha, radius) {
    this.x = x;
    this.y = y;
    this._width = width;
    this._height = height;
    this.fill = fill;
    this.stroke = stroke;
    this._alpha = alpha;
    this._radius = radius || 0;
}
#+END_SRC

These fields are then used in the other methods, such as `draw()`,
which draws the Glyph to a provided canvas context. All of the
`draw()` methods use basic HTML5 canvas commands. A snippet of `BoxGlyph.draw()`
follows; the function argument is a HTML5 canvas context to perform the
drawing actions on:

# TODO this one needs to be reformatted Done?
#+name: code:glyph-bd-2
#+BEGIN_SRC javascript
  BoxGlyph.prototype.draw = function(g) {
      var r = this._radius;
    // ...
      if (this._alpha != null) {
          g.save();
          g.globalAlpha = this._alpha;
      }

      if (this.fill) {
          g.fillStyle = this.fill;
          g.fillRect(this.x, this.y,
                     this._width,
                     this._height);
      }

      if (this.stroke) {
          g.strokeStyle = this.stroke;
          g.lineWidth = 0.5;
          g.strokeRect(this.x, this.y,
                       this._width,
                       this._height)
      }

      if (this._alpha != null) {
          g.restore();
      }
  }
#+END_SRC

Note that the HTML5 canvas context is stateful, and commands such
as "fillRect" and "strokeRect" draw shapes using the current state,
which is set with e.g. the `fillStyle` and `strokeStyle` fields.


# WIP .toSVG() using thin wrapper around DOM API
BD supports exporting the browser view to SVG, which is accomplished by
each Glyph having a `toSVG` method. `toSVG()` returns an SVG element
representing the glyph in question.

#+name: code:glyph-bd-3
#+BEGIN_SRC javascript
  BoxGlyph.prototype.toSVG = function() {
      var s = makeElementNS(NS_SVG, 'rect', null,
                           {x: this.x,
                            y: this.y,
                            width: this._width,
                            height: this._height,
                            stroke: this.stroke || 'none',
                            strokeWidth: 0.5,
                            fill: this.fill || 'none'});

      if (this._alpha != null) {
          s.setAttribute('opacity', this._alpha);
      }

      return s;
  }
#+END_SRC

# WIP .min(), .max(), .height(), minY(), maxY()
Constant functions `min()`, `max()`, and so on, are used to calculate
the bounding boxes of glyphs, to detect whether a user has clicked
on a glyph:

#+name: code:glyph-bd-4
#+BEGIN_SRC javascript
BoxGlyph.prototype.min = function() {
    return this.x;
}

BoxGlyph.prototype.max = function() {
    return this.x + this._width;
}

BoxGlyph.prototype.height = function() {
    return this.y + this._height;
}
#+END_SRC



# WIP problems: difficult to create new glyphs,
#              difficult to add new glyphs to rendering system
The problems with this way of creating and working with glyphs
largely relate to code duplication, and it being difficult to
compose existing glyphs to create new ones. Having to explicitly
write these various functions provide many opportunities for
mistakes to sneak their way in.


# WIP solution: Free monads and code generation!
In GGB, we instead use a Free monad to provide a simple DSL for describing
Glyphs. The DSL is then interpreted into functions for rendering it to a HTML5
canvas, as an SVG element, and bounding boxes. This vastly reduces the
places where mistakes can be made, and also makes it easy to test --
the canvas rendering code need only be written once and then used by all
Glyphs, and it can be tested on its own.

** Glyphs in the Genetics Graph Browser
We require some types to represent our Glyphs. First, a simple `Point`
type representing a point in 2D space, and the `GlyphF` type which
contains the commands in our Glyph DSL:

#+name: code:glyph-ggb-1
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
type Point = { x :: Number, y :: Number }

data GlyphF a =
    Circle Point Number a
  | Line Point Point a
  | Rect Point Point a
  | Stroke String a
  | Fill String a
  | Path (Array Point) a
#+END_SRC

The type parameter `a` in `GlyphF` is there so we can create a Functor
instance. This is important, because the Free monad wraps a Functor.
To reduce boilerplate, we let the compiler derive the Functor instance
for GlyphF -- if a type can be made into a Functor, there is only one
implementation, and it is mechanical.

# TODO the Functor instance in PS's implementation of Free is provided
#      by the Yoneda lemma, so this doesn't quite apply
#+name: code:glyph-ggb-2
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
derive instance functorGlyph :: Functor GlyphF
#+END_SRC

The Free monad is named so because it is the

In Haskell, the definition is very simple, thanks to non-strict evaluation:

#+name: code:glyph-ggb-3
#+BEGIN_SRC haskell
data Free f a = Pure a
              | Bind f (Free f a)
#+END_SRC

# NOTE: this is probably overkill; especially the stuff with ((,) a)
Here, `f` is the underlying functor, and `a` is whatever value we want to return.
`Free` provides two value constructors; one containing only a single value (equivalent
to the `pure` function in the Applicative typeclass), the other containing a value
in our underlying functor, which in turn contains the next "step" in the computation
in the Free monad. The Free monad can be seen as a list of commands in a DSL,
where said DSL is defined entirely in the underlying functor. Another way of
looking at it is as a list of functors. In fact, if the underlying functor
is `(,) a`, that is, the type of two-element pairs where the first element is
of some type `a`, we have a type that is isomorphic to a regular list:


#+name: code:glyph-ggb-4
#+BEGIN_SRC haskell
  type List a = Free ((,) a) ()

  [1,2,3] ~ Bind (1,
               Bind (2,
                  Bind (3, (Pure ()))))
#+END_SRC

The Purescript definition of Free is more complicated, so as to be stack-safe in
a strict language. However, the rest of the code is in Purescript.

The free monad constructs a list of commands, and these commands can then be
interpreted into some other functor, including effectful ones. Examples will
come; there is some work left before we get there. First we wrap our `GlyphF`
functor in `Free`, with a type synonym to make things cleaner:

#+name: code:glyph-ggb-5
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
type Glyph = Free GlyphF
#+END_SRC

Next we want to lift our `GlyphF` data constructors into functions. This is
done using the `liftF` function, which has the following signature:

#+name: code:glyph-ggb-6
#+BEGIN_SRC purescript
liftF :: forall f a. f a ~> Free f a
#+END_SRC

Here we use `liftF` to lift two of the commands in `GlyphF` to `Free GlyphF`,
the rest are exactly analogous and elided:

#+name: code:glyph-ggb-7
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
circle :: Point -> Number -> Glyph Unit
circle p r = liftF $ Circle p r unit

line :: Point -> Point -> Glyph Unit
line p1 p2 = liftF $ Line p1 p2 unit

stroke :: String -> Glyph Unit
stroke c = liftF $ Stroke c unit

-- ..
#+END_SRC

Since it's a monad, we also can use
do-notation to create glyphs, after creating some helper functions:

Now we have a number of functions which produce values in the type
`Free GlyphF`. With them, we can use Purescript's do-notation, and all
the other tools that come with the Monad typeclass. As an example, in
code block [[code:glyph-ggb-8]] we create a simple glyph consisting of
a red `X` over a black circle.

#+name: code:glyph-ggb-8
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
crossedOut :: Point -> Number -> Glyph Unit
crossedOut p@{x,y} r = do
  stroke "black"
  circle p r
  stroke "red"
  line {x:x-r, y:y-r} {x:x+r, y:y+r}
  line {x:x-r, y:y+r} {x:x+r, y:y-r}
#+END_SRC

A Glyph, then, is simply a data structure. The interesting part lies in
interpreting this data structure; or, in other words, transforming it into
another data structure, especially one that performs effects. In fact, an
interpreter consists of a natural transformation from the `GlyphF` functor to some
other functor.

We continue with a simple interpreter, one which transforms a `Glyph` into
a `String`, which can then be printed to console, or otherwise logged.

** Logging glyphs
The GlyphF.Log interpreter transforms Glyphs to Strings, which we can then log
to the console. To run an interpreter, we use `foldFree`; see [[code:glyph-log-1]]
for its type signature.

# TODO this one needs to be reformatted
#+name: code:glyph-log-1
#+BEGIN_SRC purescript
foldFree :: forall f m.
            MonadRec m
         => (f ~> m)
         -> (Free f)
         ~> m
#+END_SRC

# TODO this is probably overly granular
The `MonadRec` constraint ensures that only monads supporting tail recursion can be
used. Without it stack safety would be a problem. The type operator ~> denotes a
natural transformation, it has the same meaning as:
#+name: code:glyph-log-2
#+BEGIN_SRC purescript
forall a. f a -> g a
#+END_SRC

That is, it is parametrically polymorphic mapping between functors, and so cannot
touch the contents of the functor.

For producing a String, the Writer type is a natural fit, and conveniently also
has a MonadRec instance. The type of the natural transformation is then:

#+name: code:glyph-log-3
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
glyphLogN :: GlyphF ~> Writer String
#+END_SRC

The definition of the function is also simple enough. For each primitive, write an
appropriate string, and return the contents of the functor:

#+name: code:glyph-log-4
# #+BEGIN_SRC purescript
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
glyphLogN (Stroke c a)   = do
  tell $ "Set stroke style to " <> c
  pure a

glyphLogN (Circle p r a) = do
  tell $ "Drawing circle at ("
      <> show p.x <> ", "
      <> show p.y
      <> ") with radius "
      <> show r <> "."
  pure a
#+END_SRC


# this one is just to make the code compile; not exported to latex/PDF
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs :exports none
glyphLogN (Line _ _ a) = pure a
glyphLogN (Rect _ _ a) = pure a
glyphLogN (Fill _ a) = pure a
glyphLogN (Path _ a) = pure a
#+END_SRC


Running the interpreter consists of applying this natural transformation to the Free GlyphF,
using foldFree, and then getting the resulting String from the Writer. The function `showGlyph` nearly
writes itself at this point, as seen in code block [[code:glyph-log-5]].

#+name: code:glyph-execWriter
#+BEGIN_SRC purescript
execWriter :: forall w a. Writer w a -> w
#+END_SRC

#+name: code:glyph-log-5
#+BEGIN_SRC purescript :file Glyph.purs :prologue Imports/Glyph.purs
showGlyph :: forall a. Glyph a -> String
showGlyph = execWriter <<< foldFree glyphLogN
#+END_SRC

For example, logging the process of drawing the previously defined `crossedOut` glyph
at the point `{ x: 40.0, y: 10.0 }` with radius `3.0` would produce the output seen
in block [[code:glyph-log-6]].

#+name: code:glyph-log-6
#+BEGIN_VERBATIM
Drawing circle at (40.0, 10.0) with radius 3.0
Drawing line from (37.0, 7.0) to (43.0, 13.0)
Drawing line from (37.0, 13.0) to (43.0, 7.0)
#+END_VERBATIM

** Drawing glyphs to canvas and SVG
When drawing to canvas, we use Eff as the target for our natural transformation.
Interpretation is done by performing the appropriate canvas effects, see code
block [[code:glyph-draw-1]]. `glyphEffN` is then used in `renderGlyph`, in block
[[code:glyph-draw-2]], to interpret an entire `Glyph` structure into a canvas
instruction.

Code can be found [[https://github.com/chfi/purescript-genetics-browser/blob/3370abca91d66363966447dc5948d6fa133cd579/src/Genetics/Browser/GlyphF/Canvas.purs][on Github]].

#+name: code:glyph-canvas-imports
#+BEGIN_SRC purescript :file GlyphCanvas.purs :prologue Imports/GlyphCanvas.purs
import Graphics.Canvas as C
import Graphics.Canvas (CANVAS, Context2D)
#+END_SRC

#+name: code:glyph-draw-1
#+BEGIN_SRC purescript :file GlyphCanvas.purs :prologue Imports/GlyphCanvas.purs
glyphEffN :: forall eff.
             Context2D
          -> GlyphF
          ~> Eff (canvas :: CANVAS | eff)
glyphEffN ctx (Stroke c a) = do
  _ <- C.setStrokeStyle c ctx
  pure a
glyphEffN ctx (Circle p r a) = do
  _ <- C.beginPath ctx
  _ <- C.arc ctx { x: p.x
                 , y: p.y
                 , r: r
                 , start: 0.0
                 , end: 2.0 * Math.pi
                 }
  _ <- C.stroke ctx
  _ <- C.fill ctx
  pure a
-- ..
#+END_SRC

# Again, only to make the code compile
#+BEGIN_SRC purescript :file GlyphCanvas.purs :prologue Imports/GlyphCanvas.purs :exports none
glyphEffN _ (Line _ _ a) = pure a
glyphEffN _ (Rect _ _ a) = pure a
glyphEffN _ (Fill _ a) = pure a
glyphEffN _ (Path _ a) = pure a
#+END_SRC



#+name: code:glyph-draw-2
#+BEGIN_SRC purescript :file GlyphCanvas.purs :prologue Imports/GlyphCanvas.purs
renderGlyph :: forall eff.
               Context2D
            -> Glyph
            ~> Eff (canvas :: CANVAS | eff)
renderGlyph = foldFree <<< glyphEffN
#+END_SRC

# TODO expand on this (pure representation of SVG elements) (or remove)
SVG on the other hand interprets `Glyphs` into the `SVG` type, a monad
transformer stack defined in block [[code:glyph-draw-3]].



#+name: code:glyph-svg-imports
#+BEGIN_SRC purescript :file GlyphSVG.purs :prologue Imports/GlyphCanvas.purs
import Graphics.SVG (SVG, SVGElement)
import Graphics.SVG as SVG
#+END_SRC

#+BEGIN_SRC purescript :file GlyphSVG.purs :prologue Imports/GlyphCanvas.purs :exports none
import DOM (DOM)
import DOM.Node.Types (Element)
import Control.Monad.State (runStateT)
#+END_SRC

#+name: code:glyph-draw-3
#+BEGIN_SRC purescript
type SVG a =
  StateT SVGContext
    (Writer (Array SVGElement)) a
#+END_SRC

The result is a series of commands which can be used to produce the desired
SVG element. The interpreter is in block [[code:glyph-draw-4]], and is
very similar to the HTML canvas interpreter in block [[code:glyph-draw-1]].


# TODO this one needs to be reformatted
#+name: code:glyph-draw-4
#+BEGIN_SRC purescript :file GlyphSVG.purs :prologue Imports/GlyphCanvas.purs
interpSVGEff :: GlyphF ~> SVG
interpSVGEff (Stroke c a)  = do
  SVG.setStrokeStyle c
  pure a
interpSVGEff (Circle p r a) = do
  SVG.circle p.x p.y r
  pure a
-- ..
#+END_SRC


# Again, only to make the code compile
#+BEGIN_SRC purescript :file GlyphSVG.purs :prologue Imports/GlyphCanvas.purs :exports none
interpSVGEff (Line _ _ a) = pure a
interpSVGEff (Rect _ _ a) = pure a
interpSVGEff (Fill _ a)   = pure a
interpSVGEff (Path _ a)   = pure a
#+END_SRC

The interpreter is used in code block [[code:glyph-draw-5]], first to map
`Glyphs` to pure SVG elements, then to render the SVG elements using the DOM.

#+name: code:glyph-draw-5
#+BEGIN_SRC purescript :file GlyphSVG.purs :prologue Imports/GlyphCanvas.purs :exports none
runSVGEff :: forall a.
             Glyph a
          -> Array SVGElement
runSVGEff =
  execWriter
    <<< flip runStateT SVG.initialSVG
    <<< foldFree interpSVGEff

renderGlyph :: forall a eff.
               Glyph a
            -> Eff ( dom :: DOM | eff ) Element
renderGlyph = SVG.renderSVG <<< runSVGEff
#+END_SRC


** Generating bounding boxes
BD produces events when clicking on glyphs, events that GGB makes use
of. To do this, BD expects four constant functions on each glyph. In
Purescript, the "bounding box" type would look like `BoundingBox` in
code block [[code:glyph-bounding-box-1]]. Since `BoundingBox` is a
record, it has the exact same runtime representation that BD expects.

#+name: code:glyph-bounding-box-1
#+BEGIN_SRC purescript
type BoundingBox =
  { min :: Unit -> Number
  , max :: Unit -> Number
  , minY :: Unit -> Number
  , maxY :: Unit -> Number }
#+END_SRC

When constructing glyphs in BD, each new glyph provides its own explicit bounding box.
This is clearly insufficient for our purposes; instead, we make use of the fact
that bounding boxes form a semigroup, and in fact also a monoid. A brief
introduction of these concepts follows.

*** Semigroups and monoids
# TODO: <> can be rendered nice in latex, look that up
Semigroups and monoids are concepts from abstract algebra and category theory,
however they are immensely useful in pure FP, as they appear in many different
areas.

A semigroup is an algebraic structure consisting of a set together with an
associative binary operation. Let `S` be the set in question and `x`, `y`, `z`
any three elements from `S`, with the binary operation `<>`. If this following
law is true, we have a semigroup:

$Associativity: (x <> y) <> z == x <> (y <> z)$

# TODO use fancy N for natural numbers
Semigroups can intuitively be viewed as things that can be "appended" to each
other. For example, arrays, lists, and strings are semigroups, with the binary operation
being appending the two arguments. Another example is the natural numbers
with addition as the operation.

A monoid is a semigroup with one special element, an identity. The example from
above is a monoid if there is an element `e` in `S` such that these laws apply
for all elements `x` in `S`:

$Left identity:   x <> e == x$
$Right identity:  e <> x == x$

Again, arrays, lists, and strings are monoids, where the identity element is
the empty array/list/string. The natural numbers with addition form a monoid only if
zero is counted among the naturals; without zero, it is only a semigroup.
# TODO another example of semigroup but not monoid? NonEmpty?

With these definitions we can explore how bounding boxes form a monoid.

*** Monoidal bounding boxes
# TODO: ref to monoids and diagrams functional pearl

The type corresponding to a glyph's position is `GlyphPosition` in
block [[code:glyph-bounding-box-2]]
#+name: code:glyph-bounding-box-2
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
newtype GlyphPosition =
  GlyphPosition { min :: Number
                , max :: Number
                , minY :: Number
                , maxY :: Number
                }
#+END_SRC

# TODO this reasoning could be cleaned up; go at it more constructively.
It is a newtype wrapper over a record describing each of the four
edges of the bounding box. This is a semigroup, where the binary
operation produces the minimal bounding box that covers both inputs.
That is, we take the minimum or maximum of the respective values, to
get whichever maximizes the area covered:

#+name: code:glyph-bounding-box-3
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
instance semigroupGlyphPosition
  :: Semigroup GlyphPosition where
    append (GlyphPosition p1)
           (GlyphPosition p2) =
      GlyphPosition
        { min:  Math.min p1.min  p2.min
        , max:  Math.max p1.max  p2.max
        , minY: Math.min p1.minY p2.minY
        , maxY: Math.max p1.maxY p2.maxY
        }
#+END_SRC

Note the use of the the minimum and maximum functions from the Math module, and
how they're really doing all the heavy lifting. For `GlyphPosition` to be a
monoid, we require an identity element. We can use the fact that the semigroup
instance uses `min` and `max` as a hint. While there is no minimum or maximum
real number,
# TODO: add footnote about floating point inaccuracies... would also be better off using Maybe
we can cheat and use positive and negative infinity, which exist in JS. Then
we have:

#+name: code:glyph-bounding-box-4
#+BEGIN_SRC purescript
forall x. Math.min x  infinity == x
forall x. Math.max x -infinity == x
#+END_SRC

Now the identity `GlyphPosition` is obvious -- the minimum sides are set to
positive infinity, and the maximum sides are set to negative infinity:

#+name: code:glyph-bounding-box-5
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
instance monoidGlyphPosition
  :: Monoid GlyphPosition where
    mempty =
      GlyphPosition { min:    infinity
                    , max:  (-infinity)
                    , minY:   infinity
                    , maxY: (-infinity)
                    }
#+END_SRC

Now, with our `Monoid` instance in hand, we can write another interpreter for Glyph,
using Writer as our monad in the natural transformation, see code block [[code:glyph-bounding-box-6]].

#+name: code:glyph-bounding-box-6
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
glyphPosN :: GlyphF ~> Writer GlyphPosition
glyphPosN (Stroke _ a) = pure a
glyphPosN (Circle p r a) = do
  tell $ GlyphPosition { min: p.x - (r * 1.5)
                       , max: p.x + (r * 1.5)
                       , minY: p.y - (r * 1.5)
                       , maxY: p.y + (r * 1.5)
                       }
  pure a
-- ..
#+END_SRC

# for the compiler
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
glyphPosN (Line _ _ a) = pure a
glyphPosN (Rect _ _ a) = pure a
glyphPosN (Fill _ a)   = pure a
glyphPosN (Path _ a)   = pure a
#+END_SRC

Finally, in block [[code:glyph-bounding-box-7]] this interpreter is used exactly as
the previous Writer-based interpreters were.

#+name: code:glyph-bounding-box-7
#+BEGIN_SRC purescript :file GlyphBB.purs :prologue Imports/GlyphBB.purs :exports none
glyphToGlyphPosition :: forall a.
                        Glyph a
                     -> GlyphPosition
glyphToGlyphPosition =
  execWriter <<< foldFree glyphPosN
#+END_SRC

Now bounding boxes come for free with all `Glyphs`.

*** Testing our monoid
Semigroups and monoids have laws; while I'm reasonably confident in
having created a Real Monoid, I prefer to have my computer make sure.
To do this, I use purescript-jack, a property-based testing framework,
like QuickCheck.

First, some utility functions to generate and render GlyphPositions:

# TODO remove most if not all of the boilerplate; keep enough to intro generative testing
# TODO this is in Test.Glyph
# TODO this one needs to be reformatted

#+name: code:glyph-testing-1
#+BEGIN_SRC purescript
type ThreeGlyphs =
  { l :: GlyphPosition
  , c :: GlyphPosition
  , r :: GlyphPosition}

renderGlyphs :: ThreeGlyphs
             -> String
renderGlyphs {l,c,r} =
     "{ l: " <> show l
  <> ", c:"  <> show c
  <> ", r:"  <> show r <> "}"

genGlyphPosition :: Gen GlyphPosition
genGlyphPosition = do
  let cf = toNumber <$>
             chooseInt (-10000000) (10000000)
  min <- cf
  max <- cf
  minY <- cf
  maxY <- cf
  pure $ GlyphPosition { min, max, minY, maxY }

genThreeGlyphs :: Gen ThreeGlyphs
genThreeGlyphs = do
  l <- genGlyphPosition
  c <- genGlyphPosition
  r <- genGlyphPosition
  pure $ {l, c, r}
#+END_SRC

The law all semigroups should abide is associativity. In Jack, we
describe a Property asserting that parentheses don't matter for equality:

# TODO this one needs to be reformatted
#+name: code:glyph-testing-2
#+BEGIN_SRC purescript
prop_semigroup :: Property
prop_semigroup =
  forAllRender renderGlyphs genThreeGlyphs \pos ->
    property $ (pos.l <> pos.c) <> pos.r == pos.l <> (pos.c <> pos.r)
#+END_SRC

In addition to that, monoids require that the identity element in fact
be left and right identity. The Property:

#+name: code:glyph-testing-3
#+BEGIN_SRC purescript
prop_monoid :: Property
prop_monoid =
  forAll genGlyphPosition \pos ->
    property $ (pos <> mempty == pos) &&
               (mempty <> pos == pos)
#+END_SRC

Jack then takes care of generating GlyphPositions, ensuring that these properties hold.

# TODO test output

** Putting it all together

With these interpreters, we can create a function that produces a JS object
that is compatible with BD. BD expects a glyph to have:
- a function to draw the glyph to a provided canvas
- a function to export the glyph to SVG
- functions that provide the bounding box
- optionally the relevant feature, or data point, that was used to produce the glyph



To do this, we exploit the fact that Purescript records are JS objects,
by constructing a record with the appropriate properties, and transform
it to a Foreign value. The main function in its entirety:

# TODO actually this code is garbage code and should be rewritten (that's how I transformed a feature to a record?!)

# TODO this one needs to be reformatted
#+name: code:glyph-together-1
#+BEGIN_SRC purescript
writeGlyph' :: forall a c r.
               Maybe (Feature c r)
            -> Glyph a
            -> Foreign
writeGlyph' f g =
  toForeign
    { "draw": unsafePerformEff <<< \ctx -> Canvas.renderGlyph ctx g
    , "min": const p.min
    , "max": const p.max
    , "minY": const p.minY
    , "maxY": const p.maxY
    , "feature": f'
    , "toSVG": unsafePerformEff <<< \_ -> SVG.renderGlyph g
    }
  where p = unwrap $ glyphToGlyphPosition g
        f' = toNullable $
               (\(Feature chr min max _) -> {chr, min, max}) <$> f
#+END_SRC

Note the use of `const` to produce the constant functions that
describe the bounding box, after converting the `Glyph` to a
`GlyphPosition`, and `unsafePerformEff` to create functions that use
the canvas and SVG interpreters to produce the output expected by BD.
Since the `feature` field is optional, `toNullable` is used to
transform an eventual `Nothing` to an actual JS null, before being
placed in the record.

A helper function exists for working with `Glyphs` in the `F` functor,
which is useful when the `Glyphs` were constructed in the process of
parsing externally provided data. In case of failure, we produce a
`String` containing the errors, which is the format expected by BD:

# TODO this one needs to be reformatted
#+name: code:glyph-together-2
#+BEGIN_SRC purescript
writeGlyph :: forall a c r.
              Maybe (Feature c r)
           -> F (Glyph a)
           -> Foreign
writeGlyph f fG = case runExcept fG of
  Left errors ->
    toForeign $ fold
      $ renderForeignError <$> errors
  Right glyph -> writeGlyph' f glyph
#+END_SRC

In short, `writeGlyph` produces data, including possible errors, in exactly
the format expected by BD, while staying type safe.



# NOTE these should be in discussion or something

#+begin_comment

** Limitations/Performance
TODO inefficient -- rendering tens of thousands of glyphs can be slow,
     each glyph setting its own stroke & fill colors, even if all glyphs
     look the same
     NOTE: still pretty fast! 100k in 8 seconds, and (probably?) O(n).

# TODO cause: free monad

# TODO potential solution: free applicative

#+end_comment

** Summary
# TODO summary
