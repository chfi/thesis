* Glyphs
Glyphs are the final step before something is drawn to the screen -- or somewhere else.

To make it possible to describe a glyph once, while creating several representations
of it -- HTML5 canvas, SVG, bounding box -- a Free monad structure is used.

** Free monads
The Free monad is the monad generated by any functor `f`:

#+BEGIN_SRC purescript
data Free f a = Pure a
              | Bind f (Free f a)
#+END_SRC

Purescript has a less naive implementation than the above, for stack safety.

Free monads can be used to define light-weight DSLs. To do so, we first need
a functor that describes our language. Let's look at the one used to describe
Glyphs:

#+BEGIN_SRC purescript
data GlyphF a =
    Circle Point Number a
  | Line Point Point a
  | Rect Point Point a
  | Stroke String a
  | Fill String a
  | Path (Array Point) a

derive instance functorGlyph :: Functor GlyphF
#+END_SRC

A Point here is simply a pair of doubles.
Each data constructor here corresponds to one part of a glyph. If we use
this as the functor in Free, we have a type that corresponds to a list
of these constructors -- or, from another point of view, a list of commands
that describe parts of glyphs. To make it easier to use, each constructor
is lifted to a function:

#+BEGIN_SRC purescript
type Glyph = Free GlyphF

circle :: Point -> Number -> Glyph Unit
circle p r = liftF $ Circle p r unit

line :: Point -> Point -> Glyph Unit
line p1 p2 = liftF $ Line p1 p2 unit

-- and so on
#+END_SRC

Each of these functions create a corresponding value in the free monad.
Since it's a monad, we can use do-notation to create complex glyphs:

#+BEGIN_SRC purescript
crossedOut :: Point -> Number -> Glyph Unit
crossedOut p@{x,y} r = do
  circle p r
  line {x:x-r, y:y-r} {x:x+r, y:y+r}
  line {x:x-r, y:y+r} {x:x+r, y:y-r}
#+END_SRC

** Interpreting the DSL
To interpret this language, we write a transformation from the DSL functor
to a monad, which performs some effect for each command in the DSL. For
example, if we want to log each piece of the glyph to a String:

#+BEGIN_SRC purescript
glyphLog :: GlyphF ~> Writer String
glyphLog (Circle p r a) = do
  tell $ "Drawing circle at (" <> show p.x <> ", " <> show p.y <>
         ") with radius " <> show r <> "."
  pure a
glyphLog (Line p1 p2 a) = do
  tell $ "Drawing line from (" <> show p1.x <> ", " <> show p1.y <> ") to " <>
         "(" <> show p2.x <> ", " <> show p2.y <> ")"
  pure a
-- similar for the rest

showGlyph :: âˆ€ a. Glyph a -> String
showGlyph = execWriter <<< foldFree glyphLog
#+END_SRC


The ~> arrow in glyphLog's type signature signifies a natural transformation,
it is equivalent to writing
#+BEGIN_SRC purescript
glyphLog :: forall a. GlyphF a -> Writer String a
#+END_SRC
