* Glyphs
A "glyph" is something that can be drawn to the browser display,
as well as be exported to SVG. They are also what the user interacts
with, and so have bounding boxes that are used to detect whether
the user has clicked on them, to produce browser events.

** Biodalliance
WIP Biodalliance has a bunch of classes
Biodalliance has a number of Glyphs, which are classes sharing
a basic interface -- they have a function which draws itself
to the canvas, one which produces an SVG element, as well
as functions providing the bounding boxes.

WIP "higher order" glyphs
The Glyphs range from basic geometric shapes such as boxes and
triangles, to more complex "higher order" ones, which take
other glyphs and e.g. translates them.

TODO constructor
Glyphs are created using the appropriate constructor. For
example, a Box Glyph:

#+BEGIN_SRC javascript
function BoxGlyph(x, y, width, height, fill, stroke, alpha, radius) {
    this.x = x;
    this.y = y;
    this._width = width;
    this._height = height;
    this.fill = fill;
    this.stroke = stroke;
    this._alpha = alpha;
    this._radius = radius || 0;
}
#+END_SRC

These fields are then used in the other methods, such as `draw()`,
which draws the Glyph to a provided canvas context. All of the
`draw()` methods use basic HTML5 canvas commands:

TODO fix indentation etc.
#+BEGIN_SRC javascript
  BoxGlyph.prototype.draw = function(g) {
      var r = this._radius;
    // ...
            if (this._alpha != null) {
            g.save();
            g.globalAlpha = this._alpha;
        }

        if (this.fill) {
            g.fillStyle = this.fill;
            g.fillRect(this.x, this.y, this._width, this._height);
        }

        if (this.stroke) {
            g.strokeStyle = this.stroke;
            g.lineWidth = 0.5;
            g.strokeRect(this.x, this.y, this._width, this._height)
        }

        if (this._alpha != null) {
            g.restore();
        }
    }
#+END_SRC

TODO .toSVG() using thin wrapper around DOM API

#+BEGIN_SRC javascript
  BoxGlyph.prototype.toSVG = function() {
      var s = makeElementNS(NS_SVG, 'rect', null,
                           {x: this.x,
                            y: this.y,
                            width: this._width,
                            height: this._height,
                            stroke: this.stroke || 'none',
                            strokeWidth: 0.5,
                            fill: this.fill || 'none'});

      if (this._alpha != null) {
          s.setAttribute('opacity', this._alpha);
      }

      return s;
  }
#+END_SRC

TODO .min(), .max(), .height(), minY(), maxY()
Constant functions `min()`, `max()`, and so on, are used to calculate
the bounding boxes of glyphs:

#+BEGIN_SRC javascript
BoxGlyph.prototype.min = function() {
    return this.x;
}

BoxGlyph.prototype.max = function() {
    return this.x + this._width;
}

BoxGlyph.prototype.height = function() {
    return this.y + this._height;
}
#+END_SRC

TODO where these are called from


WIP problems: difficult to create new glyphs,
               difficult to add new glyphs to rendering system
The problems with this way of creating and working with glyphs
largely relate to code duplication, and it being difficult to
compose existing glyphs to create new ones. Having to explicitly
write these various functions provide many opportunities for
mistakes to sneak their way in.


WIP solution: Free monads and code generation!
In GGB, we instead use a Free monad to provide a simple DSL for describing
Glyphs. The DSL is then interpreted into functions for rendering it to a HTML5
canvas, as an SVG element, and bounding boxes. This vastly reduces the
places where mistakes can be made, and also makes it easy to test --
the canvas rendering code need only be written once and then used by all
Glyphs, and it can be tested on its own.

** Glyphs in the Genetics Graph Browser
We require some types to represent our Glyphs. First, a simple `Point`
type representing a point in 2D space, and the `GlyphF` type which
contains the commands in our Glyph DSL:

#+BEGIN_SRC purescript
type Point = { x :: Number, y :: Number }

data GlyphF a =
    Circle Point Number a
  | Line Point Point a
  | Rect Point Point a
  | Stroke String a
  | Fill String a
  | Path (Array Point) a
#+END_SRC

The type parameter `a` in `GlyphF` is there so we can create a Functor
instance.

TODO why is functor instance important; why do we care?

#+BEGIN_SRC purescript
derive instance functorGlyph :: Functor GlyphF

data Free f a = Pure a
              | Bind f (Free f a)

type Glyph = Free GlyphF
#+END_SRC

TODO Free monad intro -- super basic

(TODO: this is poorly worded -- it's not really "putting" GlyphF in "the" free monad...)
GlyphF is the type of the primitives, and putting it in the Free monad defines a
type that is a list of glyph primitives. Since it's a monad, we also can use
do-notation to create glyphs, after creating some helper functions:

#+BEGIN_SRC purescript
liftF :: forall f. f ~> (Free f)

circle :: Point -> Number -> Glyph Unit
circle p r = liftF $ Circle p r unit

stroke :: String -> Glyph Unit
stroke c = liftF $ Stroke c unit

-- and so on
#+END_SRC

`liftF` simply lifts a functor into the Free monad. Now, we can create arbitrarily
complex glyphs with an embedded DSL:

#+BEGIN_SRC purescript
crossedOut :: Point -> Number -> Glyph Unit
crossedOut p@{x,y} r = do
  circle p r
  line {x:x-r, y:y-r} {x:x+r, y:y+r}
  line {x:x-r, y:y+r} {x:x+r, y:y-r}
#+END_SRC

A Glyph, then, is simply a data structure. The interesting part lies in interpreting
this data structure; or, in other words, transforming it into another data structure,
one that *does* something. In fact, an interpreter consists of a natural transformation
from the GlyphF functor to some other functor.

An example is in order; let's look at printing glyphs to console:

** Logging glyphs
The GlyphF.Log interpreter transforms Glyphs to Strings, which we can then log
to the console. To run an interpreter, we use foldFree:

#+BEGIN_SRC purescript
foldFree :: forall f m. MonadRec m => (f ~> m) -> (Free f) ~> m
#+END_SRC

The `MonadRec` constraint ensures that only monads supporting tail recursion can be
used. Without it stack safety would be a problem. The type operator ~> denotes a
natural transformation, it has the same meaning as:
#+BEGIN_SRC purescript
forall a. f a -> g a
#+END_SRC

That is, it is parametrically polymorphic mapping between functors, and so cannot
touch the contents of the functor.

For producing a String, the Writer type is a natural fit, and conveniently also
has a MonadRec instance. The type of the natural transformation is then:

#+BEGIN_SRC purescript
glyphLog :: GlyphF ~> Writer String
#+END_SRC

The definition of the function is also simple enough. For each primitive, write an
appropriate string, and return the contents of the functor:

#+BEGIN_SRC purescript
glyphLogN (Stroke c a)   = do
  tell $ "Set stroke style to " <> c
  pure a

glyphLog (Circle p r a) = do
  tell $ "Drawing circle at (" <> show p.x <> ", " <> show p.y <>
         ") with radius " <> show r <> "."
  pure a
-- similar for the rest
#+END_SRC

Running the interpreter consists of applying this natural transformation to the Free GlyphF,
using foldFree, and then getting the resulting String from the Writer. The function `showGlyph` nearly
writes itself at this point:

#+BEGIN_SRC purescript
execWriter :: forall w a. Writer w a -> w

showGlyph :: ∀ a. Glyph a -> String
showGlyph = execWriter <<< foldFree glyphLog
#+END_SRC


TODO add example input & output

** Drawing glyphs to canvas and SVG
When drawing to canvas, we use Eff as the target for our natural transformation,
and simply perform whatever canvas effects are appropriate:

#+BEGIN_SRC purescript
glyphEffN :: ∀ eff. Context2D -> GlyphF ~> Eff (canvas :: CANVAS | eff)
glyphEffN ctx (Stroke c a) = do
  _ <- C.setStrokeStyle c ctx
  pure a
glyphEffN ctx (Circle p r a) = do
  _ <- C.beginPath ctx
  _ <- C.arc ctx { x: p.x
                 , y: p.y
                 , r: r
                 , start: 0.0
                 , end: 2.0 * Math.pi
                 }
  _ <- C.stroke ctx
  _ <- C.fill ctx
  pure a
-- and so on

-- | Produce an effect to render the glyph to a canvas
renderGlyph :: ∀ eff. Context2D -> Glyph ~> Eff (canvas :: CANVAS | eff)
renderGlyph = foldFree <<< glyphEffN
#+END_SRC

SVG on the other hand uses the following type as target functor:
#+BEGIN_SRC purescript
type SVG a = StateT SVGContext (Writer (Array SVGElement)) a
#+END_SRC

The result is a series of commands which can be used to produce the desired
SVG element; this can then be rendered to the DOM:

#+BEGIN_SRC
interpSVGEff :: GlyphF ~> SVG
interpSVGEff (Stroke c a)  = do
  SVG.setStrokeStyle c
  pure a
interpSVGEff (Circle p r a) = do
  SVG.circle p.x p.y r
  pure a
-- and so on

runSVGEff :: ∀ a. Glyph a -> Array SVGElement
runSVGEff = execWriter <<< (flip runStateT SVG.initialSVG) <<< foldFree interpSVGEff

-- | Render a glyph to an SVG element
renderGlyph :: ∀ a eff. Glyph a -> Eff ( dom :: DOM | eff ) Element
renderGlyph = SVG.renderSVG <<< runSVGEff
#+END_SRC


** Generating bounding boxes
BD produces events when clicking on glyphs -- which GGB make use of. To do this, BD
expects four constant functions on each glyph. In Purescript, the "bounding box" type
would look like this, and could be used directly by BD:

#+BEGIN_SRC purescript
type BoundingBox = { min :: Unit -> Number
                   , max :: Unit -> Number
                   , minY :: Unit -> Number
                   , maxY :: Unit -> Number }
#+END_SRC

When constructing glyphs in BD, each new glyph provides its own explicit bounding box.
This is clearly insufficient for our purposes; instead, we make use of the fact
that bounding boxes clearly form a monoid.

*** Monoidal bounding boxes
TODO: ref to monoids and diagrams functional pearl

The type corresponding to a glyph's position is GlyphPosition:
#+BEGIN_SRC purescript
newtype GlyphPosition = GlyphPosition { min :: Number
                                      , max :: Number
                                      , minY :: Number
                                      , maxY :: Number
                                      }
#+END_SRC

It is simply a newtype wrapper over a record describing the bounding box. First,
we observe that a bounding box is a semigroup, where the result of appending
two bounding boxes is the minimal box containing both of the inputs. That is,
each of the four sides of the new bounding box is whichever of the two input
sides are outermost:

#+BEGIN_SRC purescript
instance semigroupGlyphPosition :: Semigroup GlyphPosition where
  append (GlyphPosition p1) (GlyphPosition p2) =
    GlyphPosition $ { min:  Math.min p1.min  p2.min
                    , max:  Math.max p1.max  p2.max
                    , minY: Math.min p1.minY p2.minY
                    , maxY: Math.max p1.maxY p2.maxY
                    }
#+END_SRC

Note the use of the the minimum and maximum functions from the Math module,
and how they're really doing all the heavy lifting.

To transform this into a monoid, we require an identity element. Since what
`append` does is to take the minimum or maximum of the various components,
our identity must contain the identities for minimum and maximum, i.e.
positive respective negative infinity.

#+BEGIN_SRC purescript
instance monoidGlyphPosition :: Monoid GlyphPosition where
  mempty = GlyphPosition { min:    infinity
                         , max:  (-infinity)
                         , minY:   infinity
                         , maxY: (-infinity)
                         }
#+END_SRC

Now, with our Monoid in hand, we can write another interpreter for Glyph,
using Writer as our monad in the natural transformation:

#+BEGIN_SRC purescript
glyphPosN :: GlyphF ~> Writer GlyphPosition
glyphPosN (Stroke _ a) = pure a
glyphPosN (Circle p r a) = do
  tell $ GlyphPosition { min: p.x - (r * 1.5)
                       , max: p.x + (r * 1.5)
                       , minY: p.y - (r * 1.5)
                       , maxY: p.y + (r * 1.5)
                       }
  pure a
-- and so on

glyphToGlyphPosition :: ∀ a. Glyph a -> GlyphPosition
glyphToGlyphPosition = execWriter <<< foldFree glyphPosN
#+END_SRC

With that, we get bounding boxes for free when constructing glyphs.

*** Testing our monoid
Semigroups and monoids have laws; while I'm reasonably confident in
having created a Real Monoid, I prefer to have my computer make sure.
To do this, I use purescript-jack, a property-based testing framework,
like QuickCheck.

First, some utility functions to generate and render GlyphPositions:

TODO this is in Test.Glyph
#+BEGIN_SRC purescript
type ThreeGlyphs = {l :: GlyphPosition, c :: GlyphPosition, r :: GlyphPosition}

renderGlyphs :: ThreeGlyphs -> String
renderGlyphs {l,c,r} = "{ l: " <> show l <> ", c:" <> show c <> ", r:" <> show r <> "}"

genGlyphPosition :: Gen GlyphPosition
genGlyphPosition = do
  let cf = toNumber <$> chooseInt (-10000000) (10000000)
  min <- cf
  max <- cf
  minY <- cf
  maxY <- cf
  pure $ GlyphPosition { min, max, minY, maxY }

genThreeGlyphs :: Gen ThreeGlyphs
genThreeGlyphs = do
  l <- genGlyphPosition
  c <- genGlyphPosition
  r <- genGlyphPosition
  pure $ {l, c, r}
#+END_SRC

The law all semigroups should abide is associativity. In Jack, we
describe a Property asserting that parentheses don't matter for equality:

#+BEGIN_SRC purescript
prop_semigroup :: Property
prop_semigroup =
  forAllRender renderGlyphs genThreeGlyphs \pos ->
    property $ (pos.l <> pos.c) <> pos.r == pos.l <> (pos.c <> pos.r)
#+END_SRC

In addition to that, monoids require that the identity element in fact
be left and right identity. The Property:

#+BEGIN_SRC purescript
prop_monoid :: Property
prop_monoid =
  forAll genGlyphPosition \pos ->
    property $ (pos <> mempty == pos) &&
               (mempty <> pos == pos)
#+END_SRC

Jack then takes care of generating GlyphPositions, ensuring that these properties hold.

TODO test output

** Putting it all together



** Limitations/Performance
TODO inefficient -- rendering 1000s of glyphs can be slow,
     each glyph setting its own stroke & fill colors, even if all glyphs
     look the same
     NOTE: still pretty fast! 100k in 8 seconds, and (probably?) O(n).

TODO cause: free monad

TODO potential solution: free applicative
