* Configuring Biodalliance

Just look at cbrowser.js, quick references outside if appropriate.

** Problems
Large Class.
Browser() is nearly 200 lines, but calls:
realInit() is nearly 150 lines, but calls:
realInit2() is nearly 500 lines

This indirection seems to be due to async stuff. Could be solved nices.

Divergent Change -- I mean yeah

Shotgun Surgery  -- complex state, so kind of.
  -- certainly the case for UI changes

these are the same
Feature Envy     -- digs deep and far
Message Chains - rendering? (or should that be elsewhere)

Primitive Obsession -- Yes, everything is string or number, sometimes bool.



** Run thru code
Bunch of imports, including imports from stuff like renderers, which "should"
be more modular... (my fault)


** Examples

*** Entangled types
Sources and styles are both tightly coupled and separate -- problematic...

Neat solutions in PS include mapping `Source` -> `SourceSansStyle`,
Modelling type as (Source, Style), etc. (Isomorphic)
#+BEGIN_SRC javascript
var sourcesAreEqual = sourcecompare.sourcesAreEqual;
var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
#+END_SRC


*** Defaults and browser state
Browser constructor begins with 100 lines of setting local Browser values.

Lack of commenting on what each field does; problematic when there is no
easy way to see where it is used (could be in another file, or several other files).

There is also no way to figure out what values are legal, and what they mean;
static types solve that by providing proper abstraction over the configuration,
here one must find all places the configuration value is used. Easy when it's
a boolean; not so much when it's some stringly typed "enumeration".


*** Indirection


This is just ridiculous
https://github.com/chfi/dalliance/blob/master/js/cbrowser.js#L386
#+BEGIN_SRC javascript
var pollInterval = setInterval(function() {
    if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&
        thisB.tierHolder.getBoundingClientRect().width > 0)
    {
        clearInterval(pollInterval);
        thisB.realInit2();
    }
}, 300);
#+END_SRC

All of that just to keep trying something until it succeeds.

Basically, the entire constructor, and its "subroutines" realInit and realInit2
(those names are themselves code smells), create ad-hoc browser elements,
set a bunch of default state, some of which are just values, others are
derived from other configuration or data, until the whole thing is "ready".

*** Event handlers

There's no control that each part of the configuration/construction
works as it should, nor is there any structure to it. These functions:
- Create and work with HTML elements
- set default options, configuration
- setting a whole lot of UI state, including that which is used in submenus etc.
- Sets event handlers, which are filled with code duplication, low level handling
  of events, low level responses to events. Scrolling up and down with the keys is a good example:
    The *same* code, 80 lines long, duplicated, right after another.

wouldn't even need much FP to deal with that. Just do

#+BEGIN_SRC javascript
if (ev.keyCode == 38 || ev.keyCode == 87 || // up arrow   | w
    ev.keyCode == 40 || ev.keyCode == 83) { // down arrow | s
let dY = ev.keyCode == 38 || ev.keyCode == 87 ? -1 : 1;
etc.
#+END_SRC

There are only a few lines that differ, and those only differ in the arguments
passed to some other function. Why not map the keyCodes to those arguments
and leave the rest the same?


BUT, a nice way to do this would be to map raw events to a command ADT, or free functor/monad.
Just a big pattern match on that would clean things up nicely.


*** Validation and transformations

A *lot* of the code is ad-hoc transformations, stuff like

#+BEGIN_SRC javascript
while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {
    ry = ry - st[sti].height - tier.padding;
    ++sti;
}
if (sti >= st.length) {
    return;
}
#+END_SRC

Which in a reasonable language would be a catamorphism using some function
of type `Subtier -> f Number -> f Number` where we catch errors in the
functor `f`. In another chunk of code:



Stuff like this:

#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    var a = thisB.viewStart + (rx/thisB.scale);
    var b = thisB.viewStart + (dragOrigin/thisB.scale);

    var min, max;
    if (a < b) {
        min = a|0; max = b|0;
    } else {
        min = b|0; max = a|0;
    }

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC

Compare to:

#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    let f = x => thisB.viewStart (x / thisB.scale);

    let [min,max] = [rx, dragOrigin].map(f).sort();

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC

In a typed language like PS, we could use foldMap over a Tuple:

#+BEGIN_SRC purescript
type Interval a = Tuple (Min a) (Max a)

mkInterval :: forall f a.
              Foldable f
           => Ord a
           => f a
           -> Interval a
mkInterval = foldMap f
  where f :: f a -> Interval a
        f a = Tuple (Min a) (Max a)

min, max :: forall a. Interval a -> a
min = fst
min = snd
#+END_SRC

# NOTE: just defined a 1-dimensional hitbox, like we want in GlyphPosition. Neat.

Which could be used anywhere we want an ordered pair.


This is a gem:
#+BEGIN_SRC javascript
if (opts.viewStart !== undefined && typeof(opts.viewStart) !== 'number') {
    throw Error('viewStart must be an integer');
}
#+END_SRC


This could cause problems:

#+BEGIN_SRC javascript
function Browser(opts) {
    if (!opts) {
        opts = {};
    }

    // 140 lines of setting default options

    for (var k in opts) {
        this[k] = opts[k];
    }

    // 40 lines of more configuration
}
#+END_SRC

*** Global state for local action
Also just clumsy and difficult to read

#+BEGIN_SRC purescript
if (hit && hit.length > 0 && !thisB.isDragging) {
    if (doubleClickTimeout) {
        clearTimeout(doubleClickTimeout);
        doubleClickTimeout = null;
        thisB.featureDoubleClick(hit, rx, ry);
    } else {
        doubleClickTimeout = setTimeout(function() {
            doubleClickTimeout = null;
            thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);
        }, 500);
    }
}
#+END_SRC

All of that to handle double clicks. Using purescript-behaviors, we could
define an Event on double clicks by composition (I think). Compare
to debouncing a switch with electronics vs assembly (maybe).
