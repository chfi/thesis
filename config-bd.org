* Configuring Biodalliance

Just look at cbrowser.js, quick references outside if appropriate.

** Problems
Duplicated code?

Long Method.

Large Class.
Browser() is nearly 200 lines, but calls:
realInit() is nearly 150 lines, but calls:
realInit2() is nearly 500 lines

This indirection seems to be due to async stuff. Could be solved nices.

Long Parameter List.

Divergent Change?

Shotgun Surgery.

Feature Envy?

Data Clumps?

Primitive Obsession.
  - type checking

Switch Statements?

Parallel Inheritance Hierarchies?
  Maybe something with tiers etc.?

Temporary Field?

Message Chains - rendering? (or should that be elsewhere)


** Run thru code
Bunch of imports, including imports from stuff like renderers, which "should"
be more modular... (my fault)


** Examples

Neat solutions in PS include mapping `Source` -> `SourceSansStyle`,
Modelling type as (Source, Style), etc. (Isomorphic)
#+BEGIN_SRC javascript
var sourcesAreEqual = sourcecompare.sourcesAreEqual;
var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
#+END_SRC


Browser constructor begins with 100 lines of setting local Browser values.

Lack of commenting on what each field does; problematic when there is no
easy way to see where it is used (could be in another file, or several other files).

There is also no way to figure out what values are legal, and what they mean;
static types solve that by providing proper abstraction over the configuration,
here one must find all places the configuration value is used. Easy when it's
a boolean; not so much when it's some stringly typed "enumeration".


This is just ridiculous
https://github.com/chfi/dalliance/blob/master/js/cbrowser.js#L386
#+BEGIN_SRC javascript
var pollInterval = setInterval(function() {
    if (window.getComputedStyle(thisB.browserHolderHolder).display != 'none' &&
        thisB.tierHolder.getBoundingClientRect().width > 0)
    {
        clearInterval(pollInterval);
        thisB.realInit2();
    }
}, 300);
#+END_SRC

All of that just to keep trying something until it succeeds.

Basically, the entire constructor, and its "subroutines" realInit and realInit2
(those names are themselves code smells), create ad-hoc browser elements,
set a bunch of default state, some of which are just values, others are
derived from other configuration or data, until the whole thing is "ready".

There's no control that each part of the configuration/construction
works as it should, nor is there any structure to it. These functions:
- Create and work with HTML elements
- set default options, configuration
- setting a whole lot of UI state, including that which is used in submenus etc.
- Sets event handlers, which are filled with code duplication, low level handling
  of events, low level responses to events. Scrolling up and down with the keys is a good example:
    The *same* code, 80 lines long, duplicated, right after another.

wouldn't even need much FP to deal with that. Just do

#+BEGIN_SRC javascript
if (ev.keyCode == 38 || ev.keyCode == 87 || // up arrow   | w
    ev.keyCode == 40 || ev.keyCode == 83) { // down arrow | s
let dY = ev.keyCode == 38 || ev.keyCode == 87 ? -1 : 1;
etc.
#+END_SRC

There are only a few lines that differ, and those only differ in the arguments
passed to some other function. Why not map the keyCodes to those arguments
and leave the rest the same?


BUT, a nice way to do this would be to map raw events to a command ADT, or free functor/monad.
Just a big pattern match on that would clean things up nicely.


A *lot* of the code is ad-hoc transformations, stuff like

#+BEGIN_SRC javascript
while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {
    ry = ry - st[sti].height - tier.padding;
    ++sti;
}
if (sti >= st.length) {
    return;
}
#+END_SRC

Which in a reasonable language would be a catamorphism using some function
of type `Subtier -> f Number -> f Number` where we catch errors in the
functor `f`. In another chunk of code:

#+BEGIN_SRC purescript
if (hit && hit.length > 0 && !thisB.isDragging) {
    if (doubleClickTimeout) {
        clearTimeout(doubleClickTimeout);
        doubleClickTimeout = null;
        thisB.featureDoubleClick(hit, rx, ry);
    } else {
        doubleClickTimeout = setTimeout(function() {
            doubleClickTimeout = null;
            thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);
        }, 500);
    }
}
#+END_SRC

All of that to handle double clicks. Using purescript-behaviors, we could
define an Event on double clicks by composition (I think). Compare
to debouncing a switch with electronics vs assembly (maybe).

Stuff like this:

#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    var a = thisB.viewStart + (rx/thisB.scale);
    var b = thisB.viewStart + (dragOrigin/thisB.scale);

    var min, max;
    if (a < b) {
        min = a|0; max = b|0;
    } else {
        min = b|0; max = a|0;
    }

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC

Compare to:

#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    let f = x => thisB.viewStart (x / thisB.scale);

    let [min,max] = [rx, dragOrigin].map(f).sort();

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC

In a typed language like PS, we could use foldMap over a Tuple:

#+BEGIN_SRC purescript
type Interval a = Tuple (Min a) (Max a)

mkInterval :: forall f a.
              Foldable f
           => Ord a
           => f a
           -> Interval a
mkInterval = foldMap f
  where f :: f a -> Interval a
        f a = Tuple (Min a) (Max a)

min, max :: forall a. Interval a -> a
min = fst
min = snd
#+END_SRC

# NOTE: just defined a 1-dimensional hitbox, like we want in GlyphPosition. Neat.

Which could be used anywhere we want an ordered pair.
