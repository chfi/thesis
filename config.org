* Configuration

# NOTE: give an intro on the state-of-the-art - we move that to the main
# intro later. Explain *why* you decided for this architecture - late
# type checking. (late type checking is more Events; much of this chapter
# probably ought to be refactored to that chapter)

# Note: configuration is a big topic, so deserves a large chapter. Configuration
# with the type system leaves little necessary code for logic. You can prove that!
# (Pointed out that the type signature of parseBrowserConfig provides a lot
#  of information)

Software needs to be configurable.  The Genetics Graph Browser (GGB)
has many pieces that can and/or need to be configured by the user or system
administrator. For example, what tracks are currently in the view.

There are also functions that need to be provided from the external JS,
such as the Biodalliance browser constructor, and the wrapper for
Purescript-defined renderers.

Configuration in standard JS solutions is not safe. A problem that can arise in
JS is, if a configuration is given as a regular JS object (string, dictionary,
etc.), and each configuration piece is simply assigned to the respective place
in the application, there is risk of some subpiece being misconfigured, or
simply missing. Worst case, the application can then crash.


** Configuring Biodalliance

To give an idea of how configuration can take place in a legacy JS codebase,
we look at BD. Many parts of BD can be configured, not just the tracks
to display. All of this is provided by the user as a single JS object,
and passed to the browser constructor which takes care of configuring
the browser.

WIP example config
A very basic browser configuration could look like this:

# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
  var biodalliance = new Browser({

        prefix: '../',
        fullScreen: true

        chr:        '19',
        viewStart:  30000000,
        viewEnd:    40000000,

        sources:      [{name: 'Genome',
                        twoBitURI:  'http://www.biodalliance.org/datasets/GRCm38/mm10.2bit',
                        desc: 'Mouse reference genome build GRCm38',
                        tier_type: 'sequence'
                       }]

  });
#+END_SRC

This object contains configuration of basic browser functionality (the
properties `prefix`, which is the relative URL for icons and such data, and
`fullScreen` which controls how the browser itself is rendered); initial browser
state (`chr`, `viewStart`, `viewEnd`, which together define the chromosome and
range of basepairs the browser displays at start); and an array of track source
definitions (`sources`), which define what data to show, and how. In this case a
mouse genome sequence is the only track.

There are many more options and ways to customize the browser itself, likewise
there are many different kinds of sources, and ways to configure them. All
configuration is provided as JS objects, and the configuration data is used
in various functions to initialize objects, from the browser itself to the
tracks it displays. Since these functions are the place where the configuration
options are defined, it is easy to add new configuration options; for the
same reason, there is no easy way to know what a configuration option does,
nor what values are legal.

We'll have a brief look at some code smells in the configuration process,
before moving on to the configuration of GGB, and how it is implemented.

*** Code Examples

**** Defaults and browser state
BD has many features, and makes use of a lot state in its main Browser object
to function. Due to this, much of the browser construction sets various
pieces of state to default values, and sets others to values from the
configuration, or uses some configuration data to create an initial value.

As a prime example of primitive obsession, nearly all of the fields set
by the browser constructor are numbers or strings, with only a few
objects. Since this is JavaScript, there is no real type checking,
though some of the code makes use of basic validation. However, it is
wordy, and does not provide much:

# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
if (opts.viewStart !== undefined && typeof(opts.viewStart) !== 'number') {
    throw Error('viewStart must be an integer');
}

this.viewStart = opts.viewStart;
#+END_SRC

Verbosity alone makes it is understandable that only a few of the many values
set are checked like this. After various defaults are set, all other
options from the configuration object are set on the browser object:
#+BEGIN_SRC javascript
// 140 lines of setting default options
for (var k in opts) {
    this[k] = opts[k];
}
#+END_SRC

Meaning if the user has somehow set an option with the same name as one
of the fields used by BD, the browser will silently use the provided
value, even though it may be entirely incorrect. E.g. providing a number
to a function expecting a HTML DOM element.

**** Entangled types (probably remove this)

Sources and styles are both tightly coupled and separate -- problematic...

Neat solutions in PS include mapping `Source` -> `SourceSansStyle`,
Modelling type as (Source, Style), etc. (Isomorphic)
# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
var sourcesAreEqual = sourcecompare.sourcesAreEqual;
var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
#+END_SRC


**** Indirection
The constructor itself calls a method `browser.realInit()` as it finishes.
This function continues much like the constructor, preparing the browser.
Finally, the method `browser.realInit2()` is called.

TODO rewrite:
Basically, the entire constructor, and its "subroutines" realInit and realInit2
(those names are themselves code smells), create ad-hoc browser elements,
set a bunch of default state, some of which are just values, others are
derived from other configuration or data, until the whole thing is "ready".

**** Event handlers
WIP last sentence probably needs rewording
The browser constructor also sets the various DOM event handlers used
by the browser's UI. A handler can be any function that takes an event
as argument, meaning it is easy to write a handler that directly takes
care of e.g. updating a UI element. That is also a problem, as every
handler that modifies some UI state is another possibility for interference
when working with the UI.

**** Validation and transformations
WIP
This style of code is commonly seen in code throughout BD, including
configuration:

# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {
    ry = ry - st[sti].height - tier.padding;
    ++sti;
}
if (sti >= st.length) {
    return;
}
#+END_SRC

This code removes the sum of the height in pixels of the tracks from a value.
It does this with external effects and state.


Stuff like this:

# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    var a = thisB.viewStart + (rx/thisB.scale);
    var b = thisB.viewStart + (dragOrigin/thisB.scale);

    var min, max;
    if (a < b) {
        min = a|0; max = b|0;
    } else {
        min = b|0; max = a|0;
    }

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC


# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
if (hit && hit.length > 0 && !thisB.isDragging) {
    if (doubleClickTimeout) {
        clearTimeout(doubleClickTimeout);
        doubleClickTimeout = null;
        thisB.featureDoubleClick(hit, rx, ry);
    } else {
        doubleClickTimeout = setTimeout(function() {
            doubleClickTimeout = null;
            thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);
        }, 500);
    }
}
#+END_SRC

All of that to handle double clicks. Using purescript-behaviors, we could
define an Event on double clicks by composition (I think). Compare
to debouncing a switch with electronics vs assembly (maybe).


**** Code smell summary
REWRITE
There's no control that each part of the configuration/construction
works as it should, nor is there any structure to it. These functions:

- Create and work with HTML elements

- set default options, configuration

- setting a whole lot of UI state, including that which is used in submenus etc.

- Sets event handlers, which are filled with code duplication, low level handling
  of events, low level responses to events. Scrolling up and down with the keys
  is a good example: The *same* code, 80 lines long, duplicated, right after
  another.

*** Another approach

The solution used in GGB is to parse the configuration at the start of the
program, from a raw Javascript JSON object into a Purescript type, with
validation and error handling and reporting. For this I opted for
purescript-foreign and purescript-argonaut, annotating all failures with error
messages, which bubble up to the main configuration parser, which returns an
error object or a successfully parsed configuration.

** BrowserConfig

The type BrowserConfig represents the highest level of the GGB configuration
hierarchy; it is the parsed version of the JS object provided by the user.
This is the definition:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle yes :prologue Imports/Config.purs
newtype BrowserConfig =
  BrowserConfig { wrapRenderer :: RenderWrapper
                , bdRenderers :: StrMap RendererInfo
                , browser :: BrowserConstructor
                , tracks :: TracksMap
                , events :: Maybe
                    { bdEventSources :: Array SourceConfig
                    , cyEventSources :: Array SourceConfig
                    }
                }
#+END_SRC

At this point, the specific types of the values in the record are irrelevant; the
important part is that they're all Purescript types, and have been parsed
and validated. The parsing is done by the parseBrowserConfig function, which
has the following type signature:

#+BEGIN_SRC purescript :tangle no
parseBrowserConfig :: Foreign -> F BrowserConfig
#+END_SRC

NOTE: add link to source, ideally make parseBrowserConfig and
BrowserConfig clickable, or add links below the script (you could
generate them from Emacs tags). Also make sure this code passes the
current version. Same for all others. Note that this will be your
documentation too.

parseBrowserConfig is a function that reads a JS object containing the necessary
information to start the GGB, for example which tracks are included in the view,
and functions for interfacing with BD.

The pattern `Foreign -> F a` really says that a function named
parseBrowserConfig is applied to Foreign type F and returns a BrowserConfig.
This type of action is ubiquitous in the modules concerning configuration,
because we use the library `purescript-foreign`. The type `Foreign` is part of
Purescript and is simply anything that comes from outside Purescript, and thus
must be parsed before any information can be extracted from them. `F` is a type
synonym:

#+BEGIN_SRC purescript :tangle no
type F = Except (NonEmptyList ForeignError)

data ForeignError =
    JSONError String
  | ErrorAtProperty String ForeignError
  | ErrorAtIndex Int ForeignError
  | TypeMismatch String String
  | ForeignError String
#+END_SRC

`Except` is practically `Either`, and lets us represent and handle exceptions within
the type system. In this case, the error type is a non-empty list of these possible
error values. If something has gone wrong, there is at least one error message
connected to it; it is simply impossible to fail a parse without providing an error message!

From the type signature, then, we see that the function name does not lie: it does
attempt to parse Foreign data into BrowserConfigs, and must fail with an error
otherwise. We know this, because the function does not have access to anything
other than the raw configuration data, which means all the pieces of the completed
BrowserConfig must be extracted from the provided configuration, or there are
default values provided in the function itself.

Let's look at one of the lines from the function definition (note: if you are new to Purescript
the syntax may look strange - ignore the details, it will slowly make sense and you
may appreciate the terseness in time).

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
parseBrowserConfig f = do
  browser <- f ! "browser" >>= readTaggedWithError "Function" "Error on 'browser':"
#+END_SRC

`F` is a monad, which in this case is simply an object containing state (Either
a NonEmptyList or an error), so what is happening here is first an attempt to
index into the "browser" property of the supplied Foreign value, followed by an
attempt to read the Javascript "tag" of the value. If the tag says the value is
a function, we're happy and cast the value to the type BrowserConstructor bound
to the name browser, which is later referred to when putting the eventual
BrowserConfig together. If the object doesn't have a "browser" property, or said
property is not a JS function, we fail, and tell the user what went wrong.

NOTE: I would move the rest of the section to a chaptor on error handling
because it is actually generic:

`readTaggedWithError` is actually simple:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
-- The type is:
readTaggedWithError :: forall a. String -> String -> Foreign -> F a
-- The implementation:
readTaggedWithError s e f = withExcept (append (pure $ ForeignError e)) $ unsafeReadTagged s f
#+END_SRC

In words, it tries to read the tag, and if unsuccessful, appends the provided error
message to the error message from unsafeReadTagged. Let's look at the types:

#+BEGIN_SRC purescript :tangle no
unsafeReadTagged :: forall a. String -> Foreign -> F a

withExcept :: forall e1 e2 a.
              (e1 -> e2)
           -> Except e1 a
           -> Except e2 a

append :: forall m. Monoid m => m -> m -> m
#+END_SRC


In this case (of the type F), the use of `withExcept` would specialize to have the type:
#+BEGIN_SRC purescript :tangle no
withExcept :: a.
             (a -> a)
           -> F a -> F a
#+END_SRC

Another way to look at it is that `withExcept` is `map` but for the error type.

** Tracks
Tracks configurations are different for BD tracks and Cy.js graphs, though both
are provided as arrays of JSON, under different properties in the `tracks`
property of the configuration object, they are treated in their respective
sections.

*** Biodalliance

Tracks using BD are configured using BD source configurations; they are
directly compatible with Biodalliance configurations. Because of this, there
is little validation on these track configurations, as there would be no
reasonable way of representing the options in Purescript, as they are
spread out over the entire BD codebase. There are, for example, numerous
properties which can describe from where the track will fetch data and what
kind of data it is, which are logically disjoint but nevertheless technically
allowed by Biodalliance (though likely with undesired results).

So, the GGB takes a hands-off approach to BD tracks, and the only validation
that takes place is that a track must have a name. If it does, the JSON object
is later sent, unaltered, to the Biodalliance constructor.

The Biodalliance constructor is another parameter that the configuration requires.
This and the `wrapRenderer :: RenderWrapper` function are required for the BD
interface to function properly, and are JS functions provided by Biodalliance.
(TODO note that wrapRenderer is only in a modified repo?)

*** Cytoscape.js

Cytoscape graphs are currently configured by providing a name and a URL from
which to fetch the elements in JSON format.



# NOTE remove the rest of the file? none of it is really relevant

** Events
# DONE? the first line should be made clearer for novices:
When a user interacts with a track, e.g. by clicking on a data point, the track
can communicate the interaction to the rest of the system, including other
tracks. The user can configure the structure of the events that a track
produces, and what a track does when receiving an event of some specific
structure, e.g. scrolling the track on receiving an event containing a position.

TODO: remove below text into the source files for documentation. You can refer
to that, but I would just continue with TrackSink here.

**** Parsing the user-provided SourceConfigs

The SourceConfig and TrackSource validation is done in Either String,
while the BrowserConfig parsing is done in the type Except (NonEmptyList ForeignError).
To actually use these functions when parsing the user-provided configuration,
we need to do a transformation like this:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
toF :: Either String ~> Except (NonEmptyList ForeignError)
#+END_SRC

Fortunately, Either and Except are isomorphic - the difference between the two is
only in how they handle errors, not what data they contain. There already exists a function
that does part of what we need:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
except :: forall e m a. Applicative m => Either e a -> Except e a
#+END_SRC

Now we need a function that brings Either String to Either (NonEmptyList ForeignError).
We can use the fact that Either is a bifunctor, meaning it has lmap:
#+BEGIN_SRC purescript :tangle no
lmap :: forall f a b c.
	Bifunctor f
     => (a -> b)
     -> f a c -> f b c
#+END_SRC

It's exactly the same as map on a normal functor, except it's on the left-hand type.

(TODO: idk if this is actually a good comparison)
The bifunctor instance on Either can be seen as letting us build up a
chain of actions to perform on both success and failure, a functional
alternative to nested if-else statements.

The final piece we need is a way to transforming a String to a
(NonEmptyList ForeignError). Looking at the definition of the
ForeignError type, there are several data constructors we could use.
Easiest is (ForeignError String), as it simply wraps a String and
doesn't require any more information. To create the NonEmptyList, we
exploit the fact that there is an Applicative instance, and use
`pure`:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
f :: String -> NonEmptyList ForeignError
f = pure <<< ForeignError
#+END_SRC

Putting it all together, we have this natural transformation:

#+BEGIN_SRC purescript :tangle no
eitherToF :: Either String ~> F
eitherToF = except <<< lmap (pure <<< ForeignError)
#+END_SRC

Now we can parse the events configuration in the BrowserConfig parser:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript :tangle no
events <- do
  evs <- f ! "eventSources"

  bd <- evs ! "bd" >>= readArray >>= traverse parseSourceConfig
  cy <- evs ! "cy" >>= readArray >>= traverse parseSourceConfig

  _ <- eitherToF $ traverse validateSourceConfig bd
  _ <- eitherToF $ traverse validateSourceConfig cy

  pure $ Just $ { bdEventSources: bd
		, cyEventSources: cy
		}
#+END_SRC

(TODO: should probably just validate in the parseSourceConfig)
Note how we discard (_ <- ...) the results from the config validation;
we only care about the validation error, since the configuration
values have already been parsed.


**** Future work
Typing events -- types are there, just not checked (also only makes
sense w/ some kinda DSL/interpreter)
