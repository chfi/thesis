* Config

# NOTE: give an intro on the state-of-the-art - we move that to the main
# intro later. Explain *why* you decided for this architecture - late
# type checking. (late type checking is more Events; much of this chapter
# probably ought to be refactored to that chapter)

# Note: configuration is a big topic, so deserves a large chapter. Configuration
# with the type system leaves little necessary code for logic. You can prove that!
# (Pointed out that the type signature of parseBrowserConfig provides a lot
#  of information)

Software needs to be configurable.  The Genetics Graph Browser (GGB)
has many pieces that can and/or need to be configured by the user or system
administrator. For example, what tracks are currently in the view.

There are also functions that need to be provided from the external JS,
such as the Biodalliance browser constructor, and the wrapper for
Purescript-defined renderers.

Configuration in standard JS solutions is not safe. A problem that can arise in
JS is, if a configuration is given as a regular JS object (string, dictionary,
etc.), and each configuration piece is simply assigned to the respective place
in the application, there is risk of some subpiece being misconfigured, or
simply missing. Worst case, the application can then crash.


** Configuring Biodalliance

To give an idea of how configuration can take place in a legacy JS codebase,
we look at BD. Many parts of BD can be configured, not just the tracks
to display. All of this is provided by the user as a single JS object,
and passed to the browser constructor which takes care of configuring
the browser.

WIP example config
A very basic browser configuration could look like this:

#+BEGIN_SRC javascript
  var biodalliance = new Browser({

        prefix: '../',
        fullScreen: true

        chr:        '19',
        viewStart:  30000000,
        viewEnd:    40000000,

        sources:      [{name: 'Genome',
                        twoBitURI:  'http://www.biodalliance.org/datasets/GRCm38/mm10.2bit',
                        desc: 'Mouse reference genome build GRCm38',
                        tier_type: 'sequence'
                       }]

  });
#+END_SRC

This object contains configuration of basic browser functionality (the
properties `prefix`, which is the relative URL for icons and such data, and
`fullScreen` which controls how the browser itself is rendered); initial browser
state (`chr`, `viewStart`, `viewEnd`, which together define the chromosome and
range of basepairs the browser displays at start); and an array of track source
definitions (`sources`), which define what data to show, and how. In this case a
mouse genome sequence is the only track.

There are many more options and ways to customize the browser itself, likewise
there are many different kinds of sources, and ways to configure them. All
configuration is provided as JS objects, and the configuration data is used
in various functions to initialize objects, from the browser itself to the
tracks it displays. Since these functions are the place where the configuration
options are defined, it is easy to add new configuration options; for the
same reason, there is no easy way to know what a configuration option does,
nor what values are legal.

We'll have a brief look at some code smells in the configuration process,
before moving on to the configuration of GGB, and how it is implemented.

*** Code Examples

**** Defaults and browser state
BD has many features, and makes use of a lot state in its main Browser object
to function. Due to this, much of the browser construction sets various
pieces of state to default values, and sets others to values from the
configuration, or uses some configuration data to create an initial value.

As a prime example of primitive obsession, nearly all of the fields set
by the browser constructor are numbers or strings, with only a few
objects. Since this is JavaScript, there is no real type checking,
though some of the code makes use of basic validation. However, it is
wordy, and does not provide much:

#+BEGIN_SRC javascript
if (opts.viewStart !== undefined && typeof(opts.viewStart) !== 'number') {
    throw Error('viewStart must be an integer');
}

this.viewStart = opts.viewStart;
#+END_SRC

Verbosity alone makes it is understandable that only a few of the many values
set are checked like this. After various defaults are set, all other
options from the configuration object are set on the browser object:
#+BEGIN_SRC javascript
// 140 lines of setting default options
for (var k in opts) {
    this[k] = opts[k];
}
#+END_SRC

Meaning if the user has somehow set an option with the same name as one
of the fields used by BD, the browser will silently use the provided
value, even though it may be entirely incorrect. E.g. providing a number
to a function expecting a HTML DOM element.

**** Entangled types (probably remove this)

Sources and styles are both tightly coupled and separate -- problematic...

Neat solutions in PS include mapping `Source` -> `SourceSansStyle`,
Modelling type as (Source, Style), etc. (Isomorphic)
#+BEGIN_SRC javascript
var sourcesAreEqual = sourcecompare.sourcesAreEqual;
var sourcesAreEqualModuloStyle = sourcecompare.sourcesAreEqualModuloStyle;
#+END_SRC


**** Indirection
The constructor itself calls a method `browser.realInit()` as it finishes.
This function continues much like the constructor, preparing the browser.
Finally, the method `browser.realInit2()` is called.

TODO rewrite:
Basically, the entire constructor, and its "subroutines" realInit and realInit2
(those names are themselves code smells), create ad-hoc browser elements,
set a bunch of default state, some of which are just values, others are
derived from other configuration or data, until the whole thing is "ready".

**** Event handlers
WIP last sentence probably needs rewording
The browser constructor also sets the various DOM event handlers used
by the browser's UI. A handler can be any function that takes an event
as argument, meaning it is easy to write a handler that directly takes
care of e.g. updating a UI element. That is also a problem, as every
handler that modifies some UI state is another possibility for interference
when working with the UI.

**** Validation and transformations
WIP
This style of code is commonly seen in code throughout BD, including
configuration:

#+BEGIN_SRC javascript
while (sti < st.length && ry > st[sti].height && sti < (st.length - 1)) {
    ry = ry - st[sti].height - tier.padding;
    ++sti;
}
if (sti >= st.length) {
    return;
}
#+END_SRC

This code removes the sum of the height in pixels of the tracks from a value.
It does this with external effects and state.


Stuff like this:

#+BEGIN_SRC javascript
if (thisB.isDragging && rx != dragOrigin && tier.sequenceSource) {
    var a = thisB.viewStart + (rx/thisB.scale);
    var b = thisB.viewStart + (dragOrigin/thisB.scale);

    var min, max;
    if (a < b) {
        min = a|0; max = b|0;
    } else {
        min = b|0; max = a|0;
    }

    thisB.notifyRegionSelect(thisB.chr, min, max);
}
#+END_SRC


#+BEGIN_SRC purescript
if (hit && hit.length > 0 && !thisB.isDragging) {
    if (doubleClickTimeout) {
        clearTimeout(doubleClickTimeout);
        doubleClickTimeout = null;
        thisB.featureDoubleClick(hit, rx, ry);
    } else {
        doubleClickTimeout = setTimeout(function() {
            doubleClickTimeout = null;
            thisB.notifyFeature(ev, hit[hit.length-1], hit, tier);
        }, 500);
    }
}
#+END_SRC

All of that to handle double clicks. Using purescript-behaviors, we could
define an Event on double clicks by composition (I think). Compare
to debouncing a switch with electronics vs assembly (maybe).


**** Code smell summary
REWRITE
There's no control that each part of the configuration/construction
works as it should, nor is there any structure to it. These functions:

- Create and work with HTML elements

- set default options, configuration

- setting a whole lot of UI state, including that which is used in submenus etc.

- Sets event handlers, which are filled with code duplication, low level handling
  of events, low level responses to events. Scrolling up and down with the keys
  is a good example: The *same* code, 80 lines long, duplicated, right after
  another.

*** Another approach

The solution used in GGB is to parse the configuration at the start of the
program, from a raw Javascript JSON object into a Purescript type, with
validation and error handling and reporting. For this I opted for
purescript-foreign and purescript-argonaut, annotating all failures with error
messages, which bubble up to the main configuration parser, which returns an
error object or a successfully parsed configuration.

** BrowserConfig

The type BrowserConfig represents the highest level of the GGB configuration
hierarchy; it is the parsed version of the JS object provided by the user.
This is the definition:

#+BEGIN_SRC purescript
newtype BrowserConfig =
  BrowserConfig { wrapRenderer :: RenderWrapper
                , bdRenderers :: StrMap RendererInfo
                , browser :: BrowserConstructor
                , tracks :: TracksMap
                , events :: Maybe
                    { bdEventSources :: Array SourceConfig
                    , cyEventSources :: Array SourceConfig
                    }
                }
#+END_SRC

At this point, the specific types of the values in the record are irrelevant; the
important part is that they're all Purescript types, and have been parsed
and validated. The parsing is done by the parseBrowserConfig function, which
has the following type signature:

#+BEGIN_SRC purescript
parseBrowserConfig :: Foreign -> F BrowserConfig
#+END_SRC

NOTE: add link to source, ideally make parseBrowserConfig and
BrowserConfig clickable, or add links below the script (you could
generate them from Emacs tags). Also make sure this code passes the
current version. Same for all others. Note that this will be your
documentation too.

parseBrowserConfig is a function that reads a JS object containing the necessary
information to start the GGB, for example which tracks are included in the view,
and functions for interfacing with BD.

The pattern `Foreign -> F a` really says that a function named
parseBrowserConfig is applied to Foreign type F and returns a BrowserConfig.
This type of action is ubiquitous in the modules concerning configuration,
because we use the library `purescript-foreign`. The type `Foreign` is part of
Purescript and is simply anything that comes from outside Purescript, and thus
must be parsed before any information can be extracted from them. `F` is a type
synonym:

#+BEGIN_SRC purescript
type F = Except (NonEmptyList ForeignError)

data ForeignError =
    JSONError String
  | ErrorAtProperty String ForeignError
  | ErrorAtIndex Int ForeignError
  | TypeMismatch String String
  | ForeignError String
#+END_SRC

`Except` is practically `Either`, and lets us represent and handle exceptions within
the type system. In this case, the error type is a non-empty list of these possible
error values. If something has gone wrong, there is at least one error message
connected to it; it is simply impossible to fail a parse without providing an error message!

From the type signature, then, we see that the function name does not lie: it does
attempt to parse Foreign data into BrowserConfigs, and must fail with an error
otherwise. We know this, because the function does not have access to anything
other than the raw configuration data, which means all the pieces of the completed
BrowserConfig must be extracted from the provided configuration, or there are
default values provided in the function itself.

Let's look at one of the lines from the function definition (note: if you are new to Purescript
the syntax may look strange - ignore the details, it will slowly make sense and you
may appreciate the terseness in time).

#+BEGIN_SRC purescript
parseBrowserConfig f = do
  browser <- f ! "browser" >>= readTaggedWithError "Function" "Error on 'browser':"
#+END_SRC

`F` is a monad, which in this case is simply an object containing state (Either
a NonEmptyList or an error), so what is happening here is first an attempt to
index into the "browser" property of the supplied Foreign value, followed by an
attempt to read the Javascript "tag" of the value. If the tag says the value is
a function, we're happy and cast the value to the type BrowserConstructor bound
to the name browser, which is later referred to when putting the eventual
BrowserConfig together. If the object doesn't have a "browser" property, or said
property is not a JS function, we fail, and tell the user what went wrong.

NOTE: I would move the rest of the section to a chaptor on error handling
because it is actually generic:

`readTaggedWithError` is actually simple:

#+BEGIN_SRC purescript
-- The type is:
readTaggedWithError :: forall a. String -> String -> Foreign -> F a
-- The implementation:
readTaggedWithError s e f = withExcept (append (pure $ ForeignError e)) $ unsafeReadTagged s f
#+END_SRC

In words, it tries to read the tag, and if unsuccessful, appends the provided error
message to the error message from unsafeReadTagged. Let's look at the types:

#+BEGIN_SRC purescript
unsafeReadTagged :: forall a. String -> Foreign -> F a

withExcept :: forall e1 e2 a.
              (e1 -> e2)
           -> Except e1 a
           -> Except e2 a

append :: forall m. Monoid m => m -> m -> m
#+END_SRC


In this case (of the type F), the use of `withExcept` would specialize to have the type:
#+BEGIN_SRC purescript
withExcept :: a.
             (a -> a)
           -> F a -> F a
#+END_SRC

Another way to look at it is that `withExcept` is `map` but for the error type.

** Tracks
Tracks configurations are different for BD tracks and Cy.js graphs, though both
are provided as arrays of JSON, under different properties in the `tracks`
property of the configuration object, they are treated in their respective
sections.

*** Biodalliance

Tracks using BD are configured using BD source configurations; they are
directly compatible with Biodalliance configurations. Because of this, there
is little validation on these track configurations, as there would be no
reasonable way of representing the options in Purescript, as they are
spread out over the entire BD codebase. There are, for example, numerous
properties which can describe from where the track will fetch data and what
kind of data it is, which are logically disjoint but nevertheless technically
allowed by Biodalliance (though likely with undesired results).

So, the GGB takes a hands-off approach to BD tracks, and the only validation
that takes place is that a track must have a name. If it does, the JSON object
is later sent, unaltered, to the Biodalliance constructor.

The Biodalliance constructor is another parameter that the configuration requires.
This and the `wrapRenderer :: RenderWrapper` function are required for the BD
interface to function properly, and are JS functions provided by Biodalliance.
(TODO note that wrapRenderer is only in a modified repo?)

*** Cytoscape.js

Cytoscape graphs are currently configured by providing a name and a URL from
which to fetch the elements in JSON format.


** Events
# DONE? the first line should be made clearer for novices:
When a user interacts with a track, e.g. by clicking on a data point, the track
can communicate the interaction to the rest of the system, including other
tracks. The user can configure the structure of the events that a track
produces, and what a track does when receiving an event of some specific
structure, e.g. scrolling the track on receiving an event containing a position.

*** TrackSource Configuration

The configuration needed for a TrackSource is a name, the JSON structure
for the event to be produced, and the JSON structure of the event produced
by the underlying track (e.g. Biodalliance).

For this another library will be used, instead of purescript-foreign,
namely purescript-argonaut.

**** Json decoding with Argonaut

Argonaut is a library for working with JSON in Purescript, including serializing
and deserializing, as well as working with the JSON trees.

One key difference to purescript-foreign and its Foreign type, Argonaut's Json
type only corresponds to actual JSON, i.e. things that are legal in JSON
formatted files. Thus, functions and other values that cannot be serialized to
JSON, cannot be represented in the Json type.

Values of type Json can be decoded, or parsed, in several ways. In this case
we're interested in walking arbitrary JSON trees and transforming lists of
paths. Before looking at how the parsing works, here is an example of a
legal SourceConfig:

#+BEGIN_SRC json
{
  "eventName": "range",
  "eventTemplate": { "chr": "Chr",
		   "minPos": "Bp",
		   "maxPos": "Bp"
  },
  "rawTemplate": { "segment": "chr",
		 "min": "minPos",
		 "max": "maxPos"
  }
}
#+END_SRC

This defines a source that parses objects/events like this one, the JS object
passed to the event handler when clicking on a feature in BD:

#+BEGIN_SRC javascript
{
  // ...
  segment: "chr11",
  min: 1241230,
  max: 1270230
  // ..
}
#+END_SRC

Into a JS object that looks like
#+BEGIN_SRC javascript
{
  chr: "chr11",
  minPos: 1241230,
  maxPos: 1270230
}
#+END_SRC

# DONE: was that legal JSON?

This is useful if several tracks produce events with the same data but in
objects that look different; the consumer of the event will only see events of
this last format. The templates provided can be of arbitrary depth and
complexity; the only rule is that each leaf is a key, and all properties be
strings (i.e. no arrays). There is some validation too, detailed later.

`eventTemplate` and `rawTemplate` are both whole structures which we're interested in.
For each leaf in the eventTemplate (including its property name), we create a path
to where the corresponding value will be placed in the finished event. Similarly,
we need to grab the path to each leaf in the rawTemplate, so we know how to grab
the value we need in the finished event, from the provided raw event.

Fortunately, Argonaut provides functions for dealing with exactly this. First,
the JCursor type describes a path to a point in a JSON tree:

#+BEGIN_SRC purescript
data JCursor =
  JIndex Int JCursor
  JField String JCursor
  JCursorTop
#+END_SRC

It can be seen as a list of accessors. If we have an object in JS:

#+BEGIN_SRC javascript
let thing = { x: [{a: 0},
                  {b: {c: true}}
		             ]};
#+END_SRC

We can grab the value at `c` with

#+BEGIN_SRC javascript
let cIs = thing.x[1].b.c;
#+END_SRC

With JCursor, this accessor chain `x[1].b.c` would look like:
#+BEGIN_SRC purescript
(JField "x"
   (JIndex 1
    (JField "b"
       (JField "c" JCursorTop))))
#+END_SRC

It's not pretty when printed like this, but fortunately not much direct manipulation
will be needed. We create these JCursors from a JSON structure like the templates
above with the function toPrims:

#+BEGIN_SRC purescript
toPrims :: Json -> List (Tuple JCursor JsonPrim)
#+END_SRC

The type JsonPrim can be viewed as exactly what it sounds like -- it represents the
legal JSON primitives: null, booleans, numbers, strings. In this case we only care
that they are strings.

This function walks through a given JSON object, and produces a list of each leaf paired
to the JCursor describing how to get to it. That is, it does exactly what we want to do with
the rawTemplate from earlier.

With the eventTemplate we don't want to pick out the leaf, but the label of the leaf.
In this case we do need to step into the JCursor structure, but only a single step,
after reversing it:

#+BEGIN_SRC purescript
insideOut :: JCursor -> JCursor

eventName <- case insideOut cursor of
	       JField s _ -> Just s
	       _          -> Nothing
#+END_SRC

The function `insideOut` does what expected and reverses the path through the tree.
We then match on the now first label, and save it as the name. If it was an array,
we fail with a Nothing.

Argonaut, especially the functions concerning JCursor, largely uses the Maybe type.
This is fine for the most part, but as this will be used in configuration,
and thus needs to tell the user what has gone wrong if the provided configuration
is faulty, it's not enough.

A more appropriate type would be Either String, which allows for failure to come
with an error message. To "lift" the functions using Maybe into Either String.
See [[source code]] for an example.


To provide the user with additional help when configuring, the source configurations
are validated to make sure the given JSON structures are legal, or "match". Given
some value that we want to have in the finished event, and all of the values we know
we can get from the raw event, if we can't find the first value among the latter,
something's wrong.

The implementation is simple. The Cursors here are grabbed from the
result of toPrims above; the JCursors themselves are unaltered.

#+BEGIN_SRC purescript
-- This is just a nicer version of Tuple JCursor String
type Cursor = { cursor :: JCursor
              , name :: String
              }

type RawCursor = Cursor
type ValueCursor = Cursor


validateTemplate :: Array RawCursor
                 -> Array ValueCursor
                 -> Either String ValueCursor
validateTemplate rcs vc =
  if any (\rc -> vc.name == rc.name) rcs
  then pure vc
  else throwError $ "Event property " <> vc.name <> " is not in raw template"
#+END_SRC

In words, if one of the many raw event cursors has the same name as the given
value cursor, it's good, otherwise throw an error. To increase this to validate
the array of cursors defining a finished event, we can make use of Either's
Applicative instance, and traverse:

#+BEGIN_SRC purescript
-- specialized to Either String and Array
traverse :: forall a b.
	          (a -> Either String b)
	       -> Array a
	       -> Either String (Array b)

validateTemplates :: Array RawCursor
                  -> Array ValueCursor
                  -> Either String (Array ValueCursor)
validateTemplates rcs = traverse (validateTemplate rcs)
#+END_SRC

The function tries to validate all given templates, and returns the first failure if there are any.
Validation of a collection of things for free!

TODO: remove below text into the source files for documentation. You can refer
to that, but I would just continue with TrackSink here.

**** Parsing the user-provided SourceConfigs

The SourceConfig and TrackSource validation is done in Either String,
while the BrowserConfig parsing is done in the type Except (NonEmptyList ForeignError).
To actually use these functions when parsing the user-provided configuration,
we need to do a transformation like this:

#+BEGIN_SRC purescript
toF :: Either String ~> Except (NonEmptyList ForeignError)
#+END_SRC

Fortunately, Either and Except are isomorphic - the difference between the two is
only in how they handle errors, not what data they contain. There already exists a function
that does part of what we need:

#+BEGIN_SRC purescript
except :: forall e m a. Applicative m => Either e a -> Except e a
#+END_SRC

Now we need a function that brings Either String to Either (NonEmptyList ForeignError).
We can use the fact that Either is a bifunctor, meaning it has lmap:
#+BEGIN_SRC purescript
lmap :: forall f a b c.
	Bifunctor f
     => (a -> b)
     -> f a c -> f b c
#+END_SRC

It's exactly the same as map on a normal functor, except it's on the left-hand type.

(TODO: idk if this is actually a good comparison)
The bifunctor instance on Either can be seen as letting us build up a
chain of actions to perform on both success and failure, a functional
alternative to nested if-else statements.

The final piece we need is a way to transforming a String to a
(NonEmptyList ForeignError). Looking at the definition of the
ForeignError type, there are several data constructors we could use.
Easiest is (ForeignError String), as it simply wraps a String and
doesn't require any more information. To create the NonEmptyList, we
exploit the fact that there is an Applicative instance, and use
`pure`:

#+BEGIN_SRC purescript
f :: String -> NonEmptyList ForeignError
f = pure <<< ForeignError
#+END_SRC

Putting it all together, we have this natural transformation:

#+BEGIN_SRC purescript
eitherToF :: Either String ~> F
eitherToF = except <<< lmap (pure <<< ForeignError)
#+END_SRC

Now we can parse the events configuration in the BrowserConfig parser:

#+BEGIN_SRC purescript
events <- do
  evs <- f ! "eventSources"

  bd <- evs ! "bd" >>= readArray >>= traverse parseSourceConfig
  cy <- evs ! "cy" >>= readArray >>= traverse parseSourceConfig

  _ <- eitherToF $ traverse validateSourceConfig bd
  _ <- eitherToF $ traverse validateSourceConfig cy

  pure $ Just $ { bdEventSources: bd
		, cyEventSources: cy
		}
#+END_SRC

(TODO: should probably just validate in the parseSourceConfig)
Note how we discard (_ <- ...) the results from the config validation;
we only care about the validation error, since the configuration
values have already been parsed.


**** Future work
Typing events -- types are there, just not checked (also only makes
sense w/ some kinda DSL/interpreter)

*** TrackSink

TrackSinks are configured by providing an event name and a callback. On the PS
side, these are type-safe, but there is no way to ensure that functions passed
from Javascript to Purescript are type-safe. BD and Cy.js TrackSinks, respectively, should
have the following types:

(TODO: PS 0.12 will be out soon; effect rows won't be used then)
#+BEGIN_SRC purescript
newtype TrackSink a = TrackSink (StrMap (Json -> a))

type BDTrackSink = TrackSink (Biodalliance -> Eff Unit)
type CyTrackSink = TrackSink (Cytoscape -> Eff Unit)
#+END_SRC

These are the "expanded" types, for clarity. Note that they are extremely
similar; the only difference is what type of browser they work on:

#+BEGIN_SRC purescript
BDTrackSink = TrackSink (StrMap (Json -> Biodalliance -> Eff Unit)
CyTrackSink = TrackSink (StrMap (Json -> Cytoscape    -> Eff Unit)
#+END_SRC

The event name is used to place the function in the correct index of the StrMap.
The callback uses currying to take both the event (as JSON) and the respective
browser instance, to be used e.g. when scrolling the Biodalliance view to an event.

The following JS code defines a Biodalliance TrackSink (and is correctly typed):
#+BEGIN_SRC javascript
var bdConsumeLoc = function(json) {
    return function(bd) {
        return function() {
            bd.setLocation(json.chr,
                           json.pos - 1000000.0,
                           json.pos + 1000000.0);
        };
    };
};

var bdTrackSinkConfig = [ { eventName: "location",
                            eventFun: bdConsumeLoc
                          }
                        ];
#+END_SRC

# NOTE: add example of passing this information into PS.

*** Running TrackSources and TrackSinks

For TrackSource and TrackSink to be usable we need to be able to create them
from the provided configurations, and provide functions for applying them to
events as appropriate.

**** TrackSource

To create a TrackSource, the provided templates are parsed and validated.
Since a TrackSource is a list of parsers, if the SourceConfig is correct,
a function from raw events to parsed events is returned, wrapped in a singleton
list and the TrackSource type:
#+BEGIN_SRC purescript
makeTrackSource :: SourceConfig -> Either String (TrackSource Event)
makeTrackSource sc = do
  rawTemplates <- parseRawTemplateConfig sc.rawTemplate
  eventTemplates <- validateTemplates rawTemplates
                    =<< parseTemplateConfig sc.eventTemplate

  pure $ TrackSource $ singleton $ \rawEvent -> do
    vals <- parseRawEvent rawTemplates rawEvent
    evData <- fillTemplate eventTemplates vals
    pure $ { name: sc.eventName, evData }
#+END_SRC

To extend the above function to work on a collection of configuration objects,
we use function composition to first attempt to use each provided configuration
to create a TrackSource, followed by combining the list of parsers into a single
one:

#+BEGIN_SRC purescript
makeTrackSources :: Array SourceConfig -> Either String (TrackSource Event)
makeTrackSources = map fold <<< traverse makeTrackSource
#+END_SRC

First `traverse` is used to try to create the TrackSources, which
returns an array of `TrackSource Event` if all were legal, or an error if
something went wrong. Next, `map` is used to apply a function to the `Right`
side of the `Either` from the use of `traverse`, and the applied function
is `fold`, which concatenates a collection of values of some monoid into
a single value -- the monoid in question is TrackSource.

This is not the only reasonable way of defining this function -- one may very
well want to collect the error messages while returning the successes. As
`makeTrackSources` demonstrates, not much code is needed to compose functions
to provide the validation logic that is desired, and there is nothing unique
about this function; all that is required is swapping out some of the functions.

# TODO an example of this! e.g. collecting both successes and failures.
# it's a fold and a tuple, basically

Finally, a way to use a TrackSource is required. The following function uses
a TrackSource to parse a provided JSON value:

#+BEGIN_SRC purescript
runTrackSource :: TrackSource Event -> Json -> Array Event
runTrackSource (TrackSource ts) raw = filterMap (_ $ raw) ts
#+END_SRC

It works by applying each function in the array wrapped by TrackSource to the
provided value, filtering out the `Nothing`s and returning an array of
successfully parsed `Events`.

**** TrackSink

A TrackSink is a map from event names to a function that handles the event,
so to make one we create a singleton map from the provided event name to
the provided function, and wrap it in the TrackSink type:

#+BEGIN_SRC purescript
makeTrackSink :: SinkConfig ~> TrackSink
makeTrackSink sc = TrackSink $ StrMap.singleton sc.eventName sc.eventFun
#+END_SRC


Using a collection of `SinkConfigs` to produce a single `TrackSink` is not
in itself complicated, but we do some validation, namely ensuring that
there are not multiple handlers for a given event:
# NOTE/TODO there is no real reason for there to only be one handler...

#+BEGIN_SRC purescript
makeTrackSinks :: ∀ a.
                  Array (SinkConfig a)
               -> Either String (TrackSink a)
makeTrackSinks scs = do
  let count = StrMap.fromFoldableWith (+) $ map (\c -> Tuple c.eventName 1) scs
      overlapping = StrMap.filter (_ > 1) count

  when (not StrMap.isEmpty overlapping)
    let error = foldMap (append "\n" <<< show) $ StrMap.keys overlapping
    in throwError $ "Overlapping tracksinks!\n" <> error

  pure $ foldMap makeTrackSink scs
  #+END_SRC

In this case, we use `foldMap` to map the `makeTrackSink` function over the
provided configurations, and then use the `TrackSink` monoid instance to
combine them -- similar to `fold <<< traverse` in the case of `TrackSource`.

To use a `TrackSink`, we see if a handler for the provided event exists.
If it does, we apply it to the contents of the event:

#+BEGIN_SRC purescript
runTrackSink :: ∀ a. TrackSink a -> Event -> Maybe a
runTrackSink (TrackSink sink) event = do
  f <- StrMap.lookup event.name sink
  pure $ f event.evData
#+END_SRC

However, since `TrackSinks` are intended to perform effects, a helper function
for that is useful. In particular, the following function creates a "thread"
(TODO footnote on JS singlethreaded) that reads events from a provided `BusRW`
(TODO define/refer to `BusRW` intro), running effectful functions from the
provided `TrackSink` if the received event has a handler:

# TODO make sure that `forkTrackSink` is correct w/o effect rows
#+BEGIN_SRC purescript
forkTrackSink :: ∀ env.
                 TrackSink (env -> Eff Unit)
              -> env
              -> BusRW Event
              -> Aff Canceler
forkTrackSink sink env bus = forkAff $ forever do
  event <- Bus.read bus

  case runTrackSink sink event of
    Nothing -> pure unit
    Just f  -> liftEff $ f env
#+END_SRC
