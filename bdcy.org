* Interfacing with existing JS
The Genome Graph Browser uses BD and Cy.js, which are both written in JS.
To interact with their respective APIs, we must use Purescript's Foreign
Function Interface (FFI).

** FFI intro
Purescript's FFI works by creating a JS source file with the same name
as the PS module which is going to be interfacing with the FFI, in
which we define the JS functions which we will be calling from PS.
This FFI module is imported into PS using the `foreign import`
keywords, and providing type signatures for the values we import.

The type signatures are not validated, and there are no guarantees
that the FFI functions will work -- the FFI is outside the type system.
Here's an example of an FFI function which takes two values and
returns their (JS-y) concatenation. In Purescript we normally have
to make sure it makes sense to transform a value to a String before
we print it, but Javascript has no such qualms:

# TODO: this might be a *terrible* example... typewise and everything

#+BEGIN_SRC javascript
exports.showStuff = function(a) {
    return function(b) {
        return function() {
            console.log(a + b);
        }
    }
}
#+END_SRC

Since JS doesn't care about the types, neither do we. The type signature
is polymorphic in its two arguments, and returns an effect:
# TODO remove row on 0.12 release
#+BEGIN_SRC purescript
foreign import showStuff :: forall a b. a -> b -> Eff _ Unit
#+END_SRC

We can also define types (and kinds, and things of other kinds) using the
`foreign import` syntax:

#+BEGIN_SRC purescript
foreign import data JSType :: Type
#+END_SRC

Now, the type `JSType` doesn't have any data constructors in Purescript,
so we can only create values of this type by writing an FFI function that
returns it. Nor can we inspect the type without the FFI; to PS, it is
entirely opaque.

** Biodalliance
# TODO remove effects on 0.12 release

To work with Biodalliance, we define a foreign type corresponding to
instances of the BD browser:
#+BEGIN_SRC purescript
foreign import data Biodalliance :: Type
#+END_SRC

We also need an FFI function to wrap the BD browser constructor. This takes
the browser constructor, another helper function, and the BD configuration
as arguments:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
foreign import initBDimpl :: forall eff.
                             Fn3
                             Foreign
                             RenderWrapper
                             BrowserConstructor
                             (HTMLElement -> Eff (bd :: BD | eff) Biodalliance)
#+END_SRC

The output of the function is a continuation that takes an HTML element to
place the BD browser in, and produces the effect to create and return the BD instance.

Biodalliance can produce events, and for GGB's event system we need to be
able to attach a handlers to parse and transmit them. We create a newtype
to wrap the events from BD (to make sure we don't use a raw event where
it shouldn't be), and an FFI function that takes a BD instance and an effectful callback,
returning an effect that attaches the callback.

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
newtype BDEvent = BDEvent Json

foreign import addFeatureListenerImpl :: forall eff a.
                                         EffFn2 (bd :: BD | eff)
                                         Biodalliance
                                         (BDEvent -> Eff eff a)
                                         Unit
#+END_SRC

# TODO this one needs to be reformatted
#+BEGIN_SRC javascript
exports.addFeatureListenerImpl = function(bd, callback) {
    bd.addFeatureListener(function(ev, feature, hit, tier) {
        callback(feature)();
    });
};
#+END_SRC

# TODO maybe some more of the interface


** Cytoscape.js
Like BD, we define a foreign type for the Cy.js browser instance. We also
have types for the Cy.js elements, collections, and a newtype wrapper
for events. Note how the CyCollection type is a type constructor:

#+BEGIN_SRC purescript
foreign import data Cytoscape :: Type

-- | Cytoscape elements (Edges and Nodes)
foreign import data Element :: Type

newtype CyEvent = CyEvent Json

-- | A cytoscape collection of elements
foreign import data CyCollection :: Type -> Type
#+END_SRC

The Cy.js constructor is similar to BD's, except we don't need to pass any
functions to it, as we have Cy.js as a dependency. We can provide a HTML
element and an array of JSON objects to be used as the initial graph:

#+BEGIN_SRC purescript
foreign import cytoscapeImpl :: forall eff.
                                EffFn2 (cy :: CY | eff)
                                (Nullable HTMLElement)
                                (Nullable JArray)
                                Cytoscape
#+END_SRC

`Nullable` is a type for dealing with `null` in the FFI. We don't actually
use `cytoscapeImpl`, instead we provide more idiomatic wrapper, so the user
can use the more common and idiomatic `Maybe`:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
cytoscape :: forall eff.
             Maybe HTMLElement
          -> Maybe JArray
          -> Eff (cy :: CY | eff) Cytoscape
cytoscape htmlEl els = runEffFn2 cytoscapeImpl (toNullable htmlEl) (toNullable els)
#+END_SRC

The Cytoscape.js instance can be worked with in multiple ways. Data can be
added to the graph, retrieved from it, and deleted:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
-- | Add a Collection of elements to the graph
foreign import graphAddCollectionImpl :: forall eff.
                                         EffFn2 (cy :: CY | eff)
                                         Cytoscape
                                         (CyCollection Element)
                                         Unit

graphAddCollection :: forall eff.
                      Cytoscape
                   -> CyCollection Element
                   -> Eff (cy :: CY | eff) Unit
graphAddCollection = runEffFn2 graphAddCollectionImpl

-- | Get all elements in the graph
foreign import graphGetCollectionImpl :: forall eff.
                                         EffFn1 (cy :: CY | eff)
                                         Cytoscape
                                         (CyCollection Element)

graphGetCollection :: forall eff.
                      Cytoscape
                   -> Eff (cy :: CY | eff) (CyCollection Element)
graphGetCollection = runEffFn1 graphGetCollectionImpl


foreign import graphRemoveCollectionImpl :: forall eff.
                                            EffFn1 (cy :: CY | eff)
                                            (CyCollection Element)
                                            (CyCollection Element)

graphRemoveCollection :: forall eff.
                         CyCollection Element
                      -> Eff ( cy :: CY | eff) (CyCollection Element)
graphRemoveCollection = runEffFn1 graphRemoveCollectionImpl
#+END_SRC

The graph layout can be controlled with the `runLayout` function, which
takes a `Layout` value to update the Cy.js browser's current layout:

#+BEGIN_SRC purescript
-- | Apply a layout to the graph
foreign import runLayoutImpl :: forall eff.
                                EffFn2 (cy :: CY | eff)
                                Cytoscape
                                Layout
                                Unit

runLayout :: forall eff.
             Cytoscape
          -> Layout
          -> Eff (cy :: CY | eff) Unit
runLayout = runEffFn2 runLayoutImpl
#+END_SRC

`Layout` is simply a newtype wrapper over `String`. The native Cy.js
layout function takes a `String` as an argument, and with this newtype wrapper
we can both easily support all the layouts supported by Cy.js -- easily
adding more if appropriate -- while staying type-safe.

#+BEGIN_SRC purescript
newtype Layout = Layout String

circle :: Layout
circle = Layout "circle"
#+END_SRC

*** Events
# WIP Events

Cy.js produces events in JSON format, a newtype wrapper is used to keep things safe
(and improve readability of type signatures):

#+BEGIN_SRC purescript
newtype CyEvent = CyEvent Json
#+END_SRC

# TODO actually should be CyEvent -> Eff Unit? problem in GGB code
The `onEvent` FFI function takes an event handler of type `CyEvent -> Eff a`,
and a `String` representing the type of event, e.g. "click" for adding a
handler on click events. The function returns an effect that attaches
the handler to the provided Cytoscape instance:

#+BEGIN_SRC purescript
onEvent :: forall a.
           Cytoscape
        -> String
        -> (CyEvent -> Eff a)
        -> Eff Unit
#+END_SRC

#+BEGIN_SRC javascript
exports.onEventImpl = function(cy, evs, callback) {
    cy.on(evs, function(e) {
        callback(e)();
    });
};
#+END_SRC


*** CyCollection

The `CyCollection` type is used to work with collections of elements in the
Cytoscape.js browser. As it is implemented in Purescript as a `foreign data import`,
there is no way to create values of this type without using the FFI, e.g.
with `graphGetCollection`. Likewise all functions that manipulate `CyCollection` values
must be implemented in terms of the FFI.

# WIP Semigroup etc.
`CyCollection` is a semigroup where the binary operation is taking the union of
the two `CyCollections`:

#+BEGIN_SRC javascript
exports.union = function(a, b) {
    return a.union(b);
};
#+END_SRC

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
foreign import union :: forall e.
                        Fn2
                        (CyCollection e)
                        (CyCollection e)
                        (CyCollection e)

instance semigroupCyCollection :: Semigroup (CyCollection e) where
  append = runFn2 union
#+END_SRC

Another common interaction with a collection is extracting a subcollection. With `CyCollection`,
we can use the `filter` function for this:

#+BEGIN_SRC purescript
-- | Filter a collection with a predicate
filter :: forall e.
          Predicate e
       -> CyCollection e
       -> CyCollection e
#+END_SRC

The FFI definition of `filter` uses the Cy.js API:

#+BEGIN_SRC javascript
exports.filterImpl = function(pred, coll) {
    return coll.filter(pred);
};
#+END_SRC

The `Predicate` type is another newtype wrapper, this time of functions from the
given type to Boolean. Since it's a newtype, it can be provided to the FFI functions
without unwrapping it.

#+BEGIN_SRC purescript
newtype Predicate e = Predicate (e -> Boolean)
#+END_SRC

The Cytoscape.js API provides some basic predicates on elements, nodes, and edges.
For example:

#+BEGIN_SRC purescript
foreign import isNode :: Predicate Element
foreign import isEdge :: Predicate Element
#+END_SRC

`Predicates` are `contravariant` in their argument, meaning they can be `contramapped`
over, which can be seen as the opposite of normal, `covariant` functors. This is
done by precomposing the `Predicate` with a function `(a -> e)`. For example,
if we have some `Predicate Json`, i.e. a function from JSON values to Boolean,
we can contramap the `elementJson` function over it, ending up with a `Predicate Element`.
This lets us filter the Cytoscape graph with all the powerful JSON parsing tools
at our disposal.

# TODO better example
#+BEGIN_SRC purescript
hasName :: Predicate Json
hasName = Predicate f
  where f json = maybe false (const true) $ json ^? _Object <<< ix "name"

elemHasName :: Predicate Element
elemHasName = elementJson >$< hasName
#+END_SRC

`Predicate` is also an instance of the `HeytingAlgebra` typeclass. This lets
us combine `Predicates` using the normal Boolean logic combinators such as
`&&` and `||`:

#+BEGIN_SRC purescript
namedNodeOrEdge :: Predicate Element
namedNodeOrEdge = (elemHasName && isNode) || isEdge
#+END_SRC


**** Tests

# WIP
`CyCollection` is unit tested to help ensure that the graph operations work
as expected. For example, the edges and nodes from a graph should both
be subsets of the graph:

# TODO this one needs to be reformatted
#+BEGIN_SRC purescript
let edges = filter isEdge eles
    nodes = filter isNode eles
when (not $ eles `contains` edges) (fail "Graph doesn't contain its edges")
when (not $ eles `contains` nodes) (fail "Graph doesn't contain its nodes")
#+END_SRC

Conversely, the union of the edges and nodes should be equal to the
original graph, and this should be commutative:

#+BEGIN_SRC purescript
(edges <> nodes) `shouldEqual` eles
(nodes <> edges) `shouldEqual` eles
(edges <> nodes) `shouldEqual` (nodes <> edges)
#+END_SRC
