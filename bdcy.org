# * Interfacing with existing JS
#+begin_comment

TODO this chapter requires more reasoning;
     all examples that are brought up should be directly
     relevant to the hypothesis.
     for example, I don't think BDEvent applies; it doesn't deserve more than two sentences,
     and and we shouldn't bash on the reader too much about newtypes.
     Same with FFI examples in general. Show one impl + foreign import per module,
     then focus on the actual PS interface.

Idea: Move solid newtype arguments to FFI intro, and then bring up one example for BD and Cy resp.
TODO need to be more consistent in what code is shown from both modules
TODO refer to code blocks via labels
TODO Add captions to code blocks

Code smells (barely applies):
Primitive obsession

TODO: write about the changes made to BD (i.e. modularized renderers, wrapRenderer)

#+end_comment

The Graph Genetics Browser embeds BD and Cy.js, which are both written
in JS. To interact with their respective APIs, we must use PS's
Foreign Function Interface (FFI).

** Foreign Function Interface Introduction
PS's FFI works by creating a JS source file with the same name
as the PS module which is going to be interfacing with the FFI, in
which we define the JS functions which we will be calling from PS.
This FFI module is imported into PS using the `foreign import`
keywords, and providing type signatures for the values we import.

The type signatures are not validated, and there are no guarantees
that the FFI functions will work -- the FFI is outside the type
system. Listing [[code:bdcy-js-untyped-example]] shows an example of an
FFI function which takes two values and prints their sum. In PS, one
would normally have to make sure it makes sense to add two values
before attempting to do so, likewise when transforming some value to a
String, however JS has no such qualms.

# TODO: this might be a *terrible* example... typewise and everything

#+caption: Unsafe function prints the result of "summing" two values, to the browser console.
#+name: code:bdcy-js-untyped-example
#+BEGIN_SRC javascript
exports.showStuff = function(a) {
    return function(b) {
        return function() {
            console.log(a + b);
        }
    }
}
#+END_SRC

JS knows nothing about the types, however when defining an FFI function
in PS, a type signature must be provided. Using the type in [[listing code:bdcy-purs-typed-example-1]]
limits using the `showStuff` function on strings, and returns an effect,
making the function pure and behave reasonably.
# TODO make sure caption exports correctly
# TODO remove row on 0.12 release
#+caption: A safe type signature for the function defined in listing [[code:bdcy-js-untyped-example]].
#+name: code:bdcy-purs-typed-example-1
#+BEGIN_SRC purescript
foreign import showStuff
  :: forall eff.
     String
  -> String
  -> Eff (console :: CONSOLE | eff) Unit
#+END_SRC


The following sections present how the FFI was used to create the
modules wrapping the BD and Cy.js APIs.


# We can also define types (and kinds, and things of other kinds) using the
# `foreign import` syntax:

# # TODO this should be inline, or at least not a full-on code block figure
# #+caption: It is also possible to define data types that can only be instanced from FFI functions.
# #+NAME: code:bdcy-purs-typed-example-2
# #+BEGIN_SRC purescript
# foreign import data JSType :: Type
# #+END_SRC

# Now, the type `JSType` doesn't have any data constructors in Purescript,
# so we can only create values of this type by writing an FFI function that
# returns it. Nor can we inspect the type without the FFI; to PS, it is
# entirely opaque.


** Biodalliance
Using `foreign import` it is possible to define types corresponding
to foreign data structures, as values for such a type can only be
created with the FFI. To work with BD, a foreign type corresponding to
instances of the BD browser is defined as in listing [[code:bdcy-bd-types-1]].

#+caption: The data type representing a BD browser instance.
#+NAME: code:bdcy-bd-types-1
#+BEGIN_SRC purescript :tangle yes :file BDCY.purs :prologue Imports/BDCY.purs
foreign import data Biodalliance :: Type
#+END_SRC

An FFI function to wrap the BD browser constructor is also required.
As seen in listing [[code:bdcy-bd-init]], this takes the browser
constructor, another helper function, and the BD configuration as
arguments. The output of the function is a continuation that takes an
HTML element to place the BD browser in, and produces the effect to
create and return the BD instance.

# TODO this one needs to be reformatted
# TODO initBDimpl or just initBD? The latter makes more sense I think.
#      the whole point is to make the FFI as small as possible;
#
#+caption: The FFI import signature for the BD browser constructor wrapper.
#+NAME: code:bdcy-bd-init
#+BEGIN_SRC purescript
foreign import initBDimpl
  :: forall eff.
     Fn3
     Foreign
     RenderWrapper
     BrowserConstructor
     (HTMLElement -> Eff (bd :: BD | eff) Biodalliance)
#+END_SRC


BD can produce events, and for GGB's event system we need to be able
to attach a handlers to parse and transmit them. Listing
[[code:bdcy-bd-events-purs]] shows newtype that wraps the events from BD,
to ensure that raw event are not used in the wrong places, and an FFI
function that takes a BD instance and an effectful callback, returning
an effect that attaches the callback.

#+NAME: code:bdcy-bd-events-purs
#+caption: Type and FFI import for BD events.
#+BEGIN_SRC purescript
newtype BDEvent = BDEvent Json

foreign import addFeatureListenerImpl
  :: forall eff a.
     EffFn2 (bd :: BD | eff)
     Biodalliance
     (BDEvent -> Eff eff a)
     Unit
#+END_SRC

In listing [[code:bdcy-bd-events-purs-ffi]] the actual foreign function
definition is provided.

# TODO this one needs to be reformatted
#+NAME: code:bdcy-bd-events-purs-ffi
#+caption: JS implementation of BD event listener function.
#+BEGIN_SRC javascript
exports.addFeatureListenerImpl = function(bd, callback) {
    bd.addFeatureListener(function(ev, feature, hit, tier) {
        callback(feature)();
    });
};
#+END_SRC

# TODO maybe some more of the interface

This is not the entire BD module, however the other functions are
similar. The corresponding Cy.js module follows.


** Cytoscape.js

Again, a foreign type for the Cy.js browser instance is required. We
also have types for Cy.js elements, collections, and, like BD, a newtype
wrapper for events. These types are in listing [[code:bdcy-cy-types-1]].

#+NAME: code:bdcy-cy-types-1
#+caption: Foreign types used in Cytoscape.js interface.
#+BEGIN_SRC purescript :tangle yes :file BDCY.purs :prologue Imports/BDCY.purs
foreign import data Cytoscape :: Type

-- | Cytoscape elements (Edges and Nodes)
foreign import data Element :: Type

-- | A cytoscape collection of elements
foreign import data CyCollection :: Type -> Type
#+END_SRC


# #+BEGIN_SRC purescript :tangle yes :file BDCY.purs :prologue Imports/BDCY.purs :exports none
# foreign import data CY :: Effect
# #+END_SRC

The Cy.js constructor is similar to BD's. Unlike BD, as
Cy.js is provided as a dependency to GGB, we can create an instance
directly with the imported Cy.js library rather than pass the
constructory explicitly as an argument. The constructor also takes an
HTML element and an array of JSON objects to be used as the initial
graph. Listing [[bdcy-cytoscape]] shows the type signature for the constructor.


#+BEGIN_COMMENT

#+NAME: code:bdcy-cytoscapeImpl
#+caption:
#+BEGIN_SRC purescript
foreign import cytoscapeImpl
  :: forall eff.
     EffFn2 (cy :: CY | eff)
     (Nullable HTMLElement)
     (Nullable JArray)
     Cytoscape
#+END_SRC


# To simplify things, we use this definition when type-checking the report
#+BEGIN_SRC purescript :tangle yes :file BDCY.purs :prologue Imports/BDCY.purs :exports none
cytoscapeImpl
  :: forall eff.
     EffFn2 (cy :: CY | eff)

     (Nullable JArray)
     Cytoscape
cytoscapeImpl = unsafeCoerce unit
#+END_SRC

`Nullable` is a type for dealing with `null` in the FFI. We don't actually
use `cytoscapeImpl`, instead we provide more idiomatic wrapper, so the user
can use the more common and idiomatic `Maybe`:

#+END_COMMENT

# TODO this one needs to be reformatted
# TODO explain runEffFn2 (or remove example)
#+NAME: code:bdcy-cytoscape
#+caption: Type of Cy.js constructor function.
#+BEGIN_SRC purescript :tangle yes :file BDCY.purs :prologue Imports/BDCY.purs
cytoscape :: forall eff.
             Maybe HTMLElement
          -> Maybe JArray
          -> Eff (cy :: CY | eff) Cytoscape
#+END_SRC

The Cy.js browser instance can be worked with in various ways. Data can be
added to the graph, retrieved from it, and deleted, using the functions
shown in listing [[code:bdcy-cytoscape-graph-1]].

# TODO this one needs to be reformatted
#+NAME: code:bdcy-cytoscape-graph-1
#+caption: Types for functions on the Cy.js graph.
#+BEGIN_SRC purescript
graphAddCollection
  :: forall eff.
     Cytoscape
  -> CyCollection Element
  -> Eff (cy :: CY | eff) Unit

graphGetCollection
  :: forall eff.
     Cytoscape
  -> Eff (cy :: CY | eff) (CyCollection Element)

graphRemoveCollection
  :: forall eff.
     CyCollection Element
  -> Eff ( cy :: CY | eff) (CyCollection Element)
#+END_SRC

The graph layout can be controlled with the `runLayout` function, see
listing [[code:bdcy-cytoscape-layout-1]], which takes a `Layout` value to
update the Cy.js browser's current layout.

#+NAME: code:bdcy-cytoscape-layout-1
#+caption: Type of `runLayout`.
#+BEGIN_SRC purescript
runLayout :: forall eff.
             Cytoscape
          -> Layout
          -> Eff (cy :: CY | eff) Unit
#+END_SRC

`Layout` is simply a newtype wrapper over `String`. See listing
[[code:bdcy-cytoscape-layout-2]]. The native Cy.js layout function takes a
`String` as an argument, and with this newtype wrapper we can both
easily support all the layouts supported by Cy.js --- easily adding
more if appropriate --- while staying type-safe.

#+NAME: code:bdcy-cytoscape-layout-2
#+caption: Layout newtype and example value.
#+BEGIN_SRC purescript
newtype Layout = Layout String

circle :: Layout
circle = Layout "circle"
#+END_SRC


# *** Events
# WIP Events

Cy.js produces events in JSON format, like BD. A newtype wrapper is used to keep things safe,
from listing [[code:bdcy-cytoscape-event-1]].

#+NAME: code:bdcy-cytoscape-event-1
#+caption: Newtype wrapper for Cy.js events.
#+BEGIN_SRC purescript
newtype CyEvent = CyEvent Json
#+END_SRC

# TODO actually should be CyEvent -> Eff Unit? problem in GGB code
The `onEvent` FFI function takes an event handler of type `CyEvent -> Eff a`,
and a `String` representing the type of event, e.g. "click" for adding a
handler on click events. The function returns an effect that attaches
the handler to the provided Cytoscape instance, and the type is given
in listing [[code:bdcy-cytoscape-event-2]].

#+NAME: code:bdcy-cytoscape-event-2
#+caption: Type for function that adds an event listener to Cy.js instance.
#+BEGIN_SRC purescript
onEvent :: forall a.
           Cytoscape
        -> String
        -> (CyEvent -> Eff a)
        -> Eff Unit
#+END_SRC


#+BEGIN_COMMENT

#+NAME: code:bdcy-cytoscape-event-3
#+caption:
#+BEGIN_SRC javascript
exports.onEventImpl = function(cy, evs, callback) {
    cy.on(evs, function(e) {
        callback(e)();
    });
};
#+END_SRC

#+END_COMMENT

These are some of the basic functions of the Cy.js API, however
unlike BD, it gets more complicated. Next some functions for
manipulating Cy.js collections are described.


*** CyCollection

The `CyCollection` type is used to work with collections of elements
in the Cytoscape.js browser. As it is implemented in Purescript as a
`foreign data import`, there is no way to create values of this type
without using the FFI, e.g. with `graphGetCollection`. Likewise all
functions that manipulate `CyCollection` values must be implemented in
terms of the FFI.

# WIP Semigroup etc.
Cy.js provides functions for combining several `CyCollection`s in
various ways. Listing [[code:bdcy-cytoscape-union-1]] shows the FFI
definition of the function that returns the union of two provided
collections, and listing [[code:bdcy-cytoscape-union-2]] the type
signature in the FFI import, taking the opportunity to also define
an instance of the Semigroup typeclass on `CyCollection` using `union`.

#+NAME: code:bdcy-cytoscape-union-1
#+caption: Foreign function wrapping the Cy.js union function on two Cy.js collections.
#+BEGIN_SRC javascript
exports.union = function(a, b) {
    return a.union(b);
};
#+END_SRC

# TODO this one needs to be reformatted
# TODO this one is probably also superfluous. This whole section should only be a page, if that.
#+NAME: code:bdcy-cytoscape-union-2
#+caption: FFI import of union and definition of Semigroup instance on CyCollection.
#+BEGIN_SRC purescript
foreign import union
  :: forall e.
     Fn2
     (CyCollection e)
     (CyCollection e)
     (CyCollection e)

instance semigroupCyCollection :: Semigroup (CyCollection e) where
  append = runFn2 union
#+END_SRC

Another common interaction with a collection is extracting a
subcollection. With `CyCollection`, we can use the `filter` function
for this, as seen in listing [[code:bdcy-cytoscape-filter-1]] (foreign
definition elided). The `Predicate` type is another newtype, wrapping
functions from the given type to Boolean.

#+NAME: code:bdcy-cytoscape-filter-1
#+caption: Filter on a CyCollection.
#+BEGIN_SRC purescript
-- | Filter a collection with a predicate
filter :: forall e.
          Predicate e
       -> CyCollection e
       -> CyCollection e
#+END_SRC


#+BEGIN_COMMENT

The FFI definition of `filter` uses the Cy.js API:

#+NAME: code:bdcy-cytoscape-filter-2
#+caption:
#+BEGIN_SRC javascript
exports.filterImpl = function(pred, coll) {
    return coll.filter(pred);
};
#+END_SRC



#  As it is a newtype, it can be provided to the
# FFI functions without unwrapping it.

#+NAME: code:bdcy-cytoscape-predicate-1
#+caption:
#+BEGIN_SRC purescript
newtype Predicate e = Predicate (e -> Boolean)
#+END_SRC


#+END_COMMENT

The Cytoscape.js API provides some basic predicates on elements,
nodes, and edges. See listing [[code:bdcy-cytoscape-predicate-2]].

#+NAME: code:bdcy-cytoscape-predicate-2
#+caption: Imported predicates on Cy.js elements.
#+BEGIN_SRC purescript
foreign import isNode :: Predicate Element
foreign import isEdge :: Predicate Element
#+END_SRC


Multiple predicates can easily be combined and manipulated. By pre-composing
a predicate on a JSON value with a function that transforms a Cy.js element into JSON,
it is easy to create new predicates on Cy.js elements. An example is given in
listing [[code:bdcy-cytoscape-predicate-3]].

# `Predicates` are "contravariant" in their argument, meaning they can be `contramapped`
# over, which can be seen as the opposite of normal, `covariant` functors. This is
# done by precomposing the `Predicate` with a function `(a -> e)`. For example,
# if we have some `Predicate Json`, i.e. a function from JSON values to Boolean,
# we can contramap the `elementJson` function over it, ending up with a `Predicate Element`.
# This lets us filter the Cytoscape graph with all the powerful JSON parsing tools
# at our disposal.

# TODO better example
#+NAME: code:bdcy-cytoscape-predicate-3
#+caption: Precomposing predicates.
#+BEGIN_SRC purescript
hasName :: Predicate Json
hasName = Predicate f
  where f json = fromMaybe false
                 $ json ^? _Object <<< ix "name"

elemHasName :: Predicate Element
elemHasName = elementJson >$< hasName
#+END_SRC

`Predicate` is also an instance of the `HeytingAlgebra` typeclass. This lets
us combine `Predicates` using the normal Boolean logic combinators such as
`&&` and `||`. See listing [[code:bdcy-cytoscape-predicate-4]] for an example.

#+NAME: code:bdcy-cytoscape-predicate-4
#+caption: Combining predicates with boolean operators.
#+BEGIN_SRC purescript
namedNodeOrEdge :: Predicate Element
namedNodeOrEdge = (elemHasName && isNode) || isEdge
#+END_SRC

The Cy.js API is considerably larger and more complex than that for BD.
To ensure correctness beyond what the types provide, the next section
briefly describes how a subset of the module is tested.


*** Tests

PS has a testing framework called `purescript-spec`, which these unit
tests are written to use. The `fail` function fails the test with the given
string, and the `shouldEqual` function fails if the two arguments are not
equal.

`CyCollection` is unit tested to help ensure that the graph operations work
as expected. For example, the edges and nodes from a graph should both
be subsets of the graph, as shown in listing [[code:bdcy-cytoscape-tests-1]].

# TODO this one needs to be reformatted
#+NAME: code:bdcy-cytoscape-tests-1
#+caption: The edges and nodes of a graph are each subsets of the graph.
#+BEGIN_SRC purescript
let edges = filter isEdge eles
    nodes = filter isNode eles
when (not $ eles `contains` edges) (fail "Graph doesn't contain its edges")
when (not $ eles `contains` nodes) (fail "Graph doesn't contain its nodes")
#+END_SRC

Conversely, the union of the edges and nodes should be equal to the
original graph, and this should be commutative, see listing [[code:bdcy-cytoscape-tests-2]].

#+NAME: code:bdcy-cytoscape-tests-2
#+caption: The union of the nodes and edges of a graph is equal to the graph.
#+BEGIN_SRC purescript
(edges <> nodes) `shouldEqual` eles
(nodes <> edges) `shouldEqual` eles
(edges <> nodes) `shouldEqual` (nodes <> edges)
#+END_SRC


** Summary
# TODO summary

Modules providing subsets of the APIs presented by BD and Cy.js
were written using PS's FFI, allowing for some degree of correctness
even when working with JS code, with additional safety created using
some unit tests in the case of the more complex parts.

These modules are, on their own, useless. The next section thus
describes the configuration system used by GGB, and how it is used
together with these modules to create BD and Cy.js browser instances.
